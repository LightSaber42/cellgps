This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.kt, **/*.kts, **/*.xml, **/*.properties, **/*.md, **/*.ps1, **/*.pro, **/*.html, **/*.txt, **/*.json, **/*.gradle, gradlew, gradlew.bat, gradle/wrapper/gradle-wrapper.jar, gradle/wrapper/gradle-wrapper.properties, .gitignore, README.md, SETUP.md, PROJECT_STRUCTURE.md, KEYSTORE_SETUP.md, PLAY_STORE_CHECKLIST.md, PRIVACY_POLICY.md, PRIVACY_POLICY_SETUP.md, ADD_PRIVACY_POLICY.md, keystore.properties.example
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
adb-screenshot.ps1
ADD_PRIVACY_POLICY.md
app/build.gradle.kts
app/proguard-rules.pro
app/src/main/AndroidManifest.xml
app/src/main/java/com/signaldrivelogger/data/CsvParser.kt
app/src/main/java/com/signaldrivelogger/data/FileLogger.kt
app/src/main/java/com/signaldrivelogger/data/LocationProvider.kt
app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt
app/src/main/java/com/signaldrivelogger/data/SignalRepository.kt
app/src/main/java/com/signaldrivelogger/data/TelephonyMonitor.kt
app/src/main/java/com/signaldrivelogger/domain/models/SignalRecord.kt
app/src/main/java/com/signaldrivelogger/service/LoggingService.kt
app/src/main/java/com/signaldrivelogger/SignalDriveLoggerApplication.kt
app/src/main/java/com/signaldrivelogger/ui/LoggingViewModel.kt
app/src/main/java/com/signaldrivelogger/ui/MainActivity.kt
app/src/main/java/com/signaldrivelogger/ui/MainScreen.kt
app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt
app/src/main/java/com/signaldrivelogger/ui/theme/Color.kt
app/src/main/java/com/signaldrivelogger/ui/theme/Theme.kt
app/src/main/java/com/signaldrivelogger/ui/theme/Type.kt
app/src/main/res/drawable/ic_launcher_foreground.xml
app/src/main/res/drawable/ic_notification.xml
app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
app/src/main/res/mipmap-hdpi/ic_launcher_round.xml
app/src/main/res/mipmap-hdpi/ic_launcher.xml
app/src/main/res/mipmap-mdpi/ic_launcher_round.xml
app/src/main/res/mipmap-mdpi/ic_launcher.xml
app/src/main/res/mipmap-xhdpi/ic_launcher_round.xml
app/src/main/res/mipmap-xhdpi/ic_launcher.xml
app/src/main/res/mipmap-xxhdpi/ic_launcher_round.xml
app/src/main/res/mipmap-xxhdpi/ic_launcher.xml
app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.xml
app/src/main/res/mipmap-xxxhdpi/ic_launcher.xml
app/src/main/res/values/colors.xml
app/src/main/res/values/strings.xml
app/src/main/res/values/themes.xml
app/src/main/res/xml/file_paths.xml
app/src/test/java/com/signaldrivelogger/data/FileLoggerTest.kt
build-error.txt
build-errors.txt
build.gradle.kts
compile-errors.txt
create-keystore.ps1
gradle.properties
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
KEYSTORE_SETUP.md
keystore.properties.example
kotlin-errors.txt
PLAY_STORE_CHECKLIST.md
PRIVACY_POLICY_SETUP.md
PRIVACY_POLICY.md
privacy-policy-cell-signal-logger.html
PROJECT_STRUCTURE.md
README.md
REPOMIX_USAGE.md
settings.gradle.kts
setup-android-env.ps1
SETUP.md
update-version.ps1

================================================================
Files
================================================================

================
File: .gitignore
================
# Built application files
*.apk
*.ap_
*.aab

# Keystore files (NEVER commit these!)
*.jks
*.keystore
*.key
keystore.properties

# Files for the ART/Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/
out/
release/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

# Android Studio captures folder
captures/

# IntelliJ
*.iml
.idea/workspace.xml
.idea/tasks.xml
.idea/gradle.xml
.idea/assetWizardSettings.xml
.idea/dictionaries
.idea/libraries
.idea/jarRepositories.xml
# Android Studio 3 in .gitignore file.
.idea/caches
.idea/modules.xml
# Comment next line if keeping position of elements in Editor is needed
.idea/uiDesigner.xml
# .idea/compiler.xml
# .idea/misc.xml

# Keystore files
# Uncomment the following lines if you do not want to check your keystore files in.
#*.jks
#*.keystore

# External native build folder generated in Android Studio 2.2 and later
.externalNativeBuild
.cxx/

# Google Services (e.g. APIs or Firebase)
# google-services.json

# Freeline
freeline.py
freeline/
freeline_project_description.json

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
fastlane/readme.md

# Version control
vcs.xml

# lint
lint/intermediates/
lint/generated/
lint/outputs/
lint/tmp/
# lint/reports/

# Screenshots folder
screenshots/

================
File: adb-screenshot.ps1
================
# ADB Screenshot Script
# Takes a screenshot from connected Android device and saves to a dedicated folder

# Create screenshots folder if it doesn't exist
$screenshotFolder = "screenshots"
if (-not (Test-Path $screenshotFolder)) {
    New-Item -ItemType Directory -Path $screenshotFolder | Out-Null
    Write-Host "Created screenshots folder: $screenshotFolder" -ForegroundColor Green
}

# Generate filename with timestamp
$timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
$filename = "$screenshotFolder\screenshot-$timestamp.png"
$fullPath = Join-Path (Get-Location) $filename

# Check if ADB is available
$adbCheck = Get-Command adb -ErrorAction SilentlyContinue
if (-not $adbCheck) {
    Write-Host "Error: ADB not found in PATH. Please ensure Android SDK platform-tools is in your PATH." -ForegroundColor Red
    exit 1
}

# Check if device is connected and get first device ID
$deviceList = adb devices
$deviceLines = $deviceList | Select-String -Pattern "\tdevice$"
if (-not $deviceLines) {
    Write-Host "Error: No Android device connected. Please connect a device and enable USB debugging." -ForegroundColor Red
    exit 1
}

# Get the first device ID (split by tab and take first part)
$firstDevice = ($deviceLines[0].Line -split "`t")[0]
Write-Host "Using device: $firstDevice" -ForegroundColor Cyan

Write-Host "Taking screenshot..." -ForegroundColor Cyan

# Take screenshot and save to file
try {
    # Capture binary output using .NET methods
    $processInfo = New-Object System.Diagnostics.ProcessStartInfo
    $processInfo.FileName = "adb"
    $processInfo.Arguments = "-s $firstDevice exec-out screencap -p"
    $processInfo.UseShellExecute = $false
    $processInfo.RedirectStandardOutput = $true
    $processInfo.CreateNoWindow = $true

    $process = New-Object System.Diagnostics.Process
    $process.StartInfo = $processInfo
    $process.Start() | Out-Null

    # Read binary data
    $binaryData = $process.StandardOutput.BaseStream
    $memoryStream = New-Object System.IO.MemoryStream
    $binaryData.CopyTo($memoryStream)
    $bytes = $memoryStream.ToArray()

    $process.WaitForExit()

    if ($process.ExitCode -ne 0) {
        throw "ADB command failed with exit code $($process.ExitCode)"
    }

    # Write binary data to file
    [System.IO.File]::WriteAllBytes($fullPath, $bytes)
    Write-Host "Screenshot saved: $fullPath" -ForegroundColor Green

    # Get file size
    $fileSize = (Get-Item $fullPath).Length / 1KB
    Write-Host "File size: $([math]::Round($fileSize, 2)) KB" -ForegroundColor Gray

    # Optionally open the screenshot
    $open = Read-Host "Open screenshot? (Y/N)"
    if ($open -eq "Y" -or $open -eq "y") {
        Start-Process $fullPath
    }
} catch {
    Write-Host "Error taking screenshot: $_" -ForegroundColor Red
    exit 1
}

================
File: ADD_PRIVACY_POLICY.md
================
# Adding Privacy Policy to achievetherapy.co.uk

## Quick Steps

1. **Copy the HTML file to your website repository:**
   - Copy `privacy-policy-cell-signal-logger.html` to your achievetherapy.co.uk GitHub repository
   - Place it in the root directory (same level as `index.html` or `privacy-policy.html`)

2. **Rename the file (optional):**
   - You can rename it to something shorter like `cell-signal-logger-privacy.html`
   - Or keep it as `privacy-policy-cell-signal-logger.html`

3. **Your privacy policy URL will be:**
   ```
   https://achievetherapy.co.uk/privacy-policy-cell-signal-logger.html
   ```
   Or if you rename it:
   ```
   https://achievetherapy.co.uk/cell-signal-logger-privacy.html
   ```

4. **Add to Play Console:**
   - Go to Play Console → Your App → Policy → App content
   - Enter: `https://achievetherapy.co.uk/privacy-policy-cell-signal-logger.html`
   - Save

## Alternative: Add Link from Main Privacy Policy

If you want to link to it from your existing privacy policy page, you can add:

```html
<p><a href="/privacy-policy-cell-signal-logger.html">Privacy Policy for Cell Signal Logger App</a></p>
```

## File Structure

Your repository structure should look like:
```
your-repo/
├── index.html
├── privacy-policy.html (existing)
├── privacy-policy-cell-signal-logger.html (new)
└── ... other files
```

## GitHub Pages Setup

If using GitHub Pages:
1. Push the HTML file to your repository
2. GitHub Pages will automatically serve it
3. The URL will be available immediately (or within a few minutes)

## Testing

After adding the file:
1. Visit: `https://achievetherapy.co.uk/privacy-policy-cell-signal-logger.html`
2. Verify it loads correctly
3. Check that all formatting looks good
4. Test the "Back to Home" link works

## Notes

- The HTML file is self-contained with inline CSS
- It matches the style of your existing privacy policy
- Uses the same contact email (info@achievetherapy.com)
- Includes "Back to Home" link for navigation

================
File: app/build.gradle.kts
================
import java.util.Properties

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

// Load keystore properties if file exists
val keystorePropertiesFile = rootProject.file("keystore.properties")
val keystoreProperties = Properties()
if (keystorePropertiesFile.exists()) {
    keystorePropertiesFile.inputStream().use {
        keystoreProperties.load(it)
    }
}

android {
    namespace = "com.signaldrivelogger"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.signaldrivelogger"
        minSdk = 26
        targetSdk = 35
        versionCode = 5
        versionName = "1.0.4"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    signingConfigs {
        if (keystorePropertiesFile.exists()) {
            create("release") {
                keyAlias = keystoreProperties["keyAlias"] as String
                keyPassword = keystoreProperties["keyPassword"] as String
                // Keystore file is in the project root directory
                val storeFilePath = keystoreProperties["storeFile"] as String
                storeFile = rootProject.file(storeFilePath)
                storePassword = keystoreProperties["storePassword"] as String
            }
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
            if (keystorePropertiesFile.exists()) {
                signingConfig = signingConfigs.getByName("release")
            }
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.14"
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    // Core Android
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.2")
    implementation("androidx.activity:activity-compose:1.8.1")

    // Compose
    implementation(platform("androidx.compose:compose-bom:2023.10.01"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.material:material-icons-extended")

    // ViewModel
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2")
    implementation("androidx.lifecycle:lifecycle-runtime-compose:2.6.2")

    // osmdroid (OpenStreetMap)
    implementation("org.osmdroid:osmdroid-android:6.1.17")

    // Location services (still needed for location tracking)
    implementation("com.google.android.gms:play-services-location:21.0.1")

    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")

    // Navigation
    implementation("androidx.navigation:navigation-compose:2.7.5")

    // Permissions
    implementation("com.google.accompanist:accompanist-permissions:0.32.0")

    // Testing
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2023.10.01"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}

================
File: app/proguard-rules.pro
================
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.

# Keep osmdroid classes
-keep class org.osmdroid.** { *; }
-dontwarn org.osmdroid.**

# Keep signal logging classes
-keep class com.signaldrivelogger.** { *; }

# Keep data classes
-keep class * implements java.io.Serializable { *; }

# Keep Parcelable implementations
-keep class * implements android.os.Parcelable {
    public static final android.os.Parcelable$Creator *;
}

================
File: app/src/main/AndroidManifest.xml
================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Permissions -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        android:name=".SignalDriveLoggerApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.SignalDriveLogger"
        tools:targetApi="31">

        <activity
            android:name=".ui.MainActivity"
            android:exported="true"
            android:theme="@style/Theme.SignalDriveLogger">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <!-- Handle shared CSV files -->
            <!-- Specific CSV MIME types -->
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/csv" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/comma-separated-values" />
            </intent-filter>
            <!-- Generic file types with CSV extension (for WhatsApp, etc.) -->
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="*/*" android:pathPattern=".*\\.csv" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="application/octet-stream" android:pathPattern=".*\\.csv" />
            </intent-filter>
            <!-- VIEW action for opening CSV files -->
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/csv" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="*/*" android:pathPattern=".*\\.csv" />
            </intent-filter>
        </activity>

        <!-- Foreground Service -->
        <service
            android:name=".service.LoggingService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="location" />

        <!-- osmdroid uses OpenStreetMap - no API key required -->

        <!-- FileProvider for sharing files -->
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

    </application>

</manifest>

================
File: app/src/main/java/com/signaldrivelogger/data/CsvParser.kt
================
package com.signaldrivelogger.data

import com.signaldrivelogger.domain.models.SignalRecord
import java.io.InputStream
import java.time.Instant

/**
 * Result of CSV parsing operation.
 */
sealed class CsvParseResult {
    data class Success(val records: List<SignalRecord>) : CsvParseResult()
    data class Error(val message: String, val lineNumber: Int? = null) : CsvParseResult()
}

/**
 * Parser for CSV files containing SignalRecord data.
 */
class CsvParser {
    companion object {
        // Expected CSV header (base fields)
        private val BASE_HEADER = listOf(
            "timestamp", "latitude", "longitude", "altitude_m", "signal_strength_dbm",
            "cell_id", "data_rate_kbps", "network_type", "asu",
            "data_state", "data_activity", "roaming", "sim_state", "sim_operator_name",
            "sim_mcc", "sim_mnc", "operator_name", "mcc", "mnc", "phone_type",
            "sim_slot_index", "subscription_id", "sim_display_name", "is_embedded"
        )

        // Extended CSV header (with new cell details)
        private val EXTENDED_HEADER = BASE_HEADER + listOf(
            "ci", "enb", "tac", "pci", "bandwidth_khz", "earfcn", "nrarfcn",
            "rssi_dbm", "rsrq_db", "snr_db", "cqi", "timing_advance"
        )

        /**
         * Parses a CSV file from an InputStream.
         */
        fun parse(inputStream: InputStream): CsvParseResult {
            return try {
                val lines = inputStream.bufferedReader().readLines()
                if (lines.isEmpty()) {
                    return CsvParseResult.Error("CSV file is empty")
                }

                // Validate header - support both old and new formats
                val header = lines[0].split(",").map { it.trim() }
                val headerLower = header.map { it.lowercase() }
                val baseHeaderLower = BASE_HEADER.map { it.lowercase() }
                val extendedHeaderLower = EXTENDED_HEADER.map { it.lowercase() }

                val isExtendedFormat = header.size == EXTENDED_HEADER.size
                val isBaseFormat = header.size == BASE_HEADER.size

                if (!isExtendedFormat && !isBaseFormat) {
                    return CsvParseResult.Error(
                        "Invalid CSV format: Expected ${BASE_HEADER.size} or ${EXTENDED_HEADER.size} columns, found ${header.size}",
                        lineNumber = 1
                    )
                }

                // Check if base header matches (case-insensitive)
                val baseMatches = headerLower.take(BASE_HEADER.size) == baseHeaderLower
                if (!baseMatches) {
                    val mismatches = headerLower.take(BASE_HEADER.size).zip(baseHeaderLower)
                        .mapIndexedNotNull { index, (actual, expected) ->
                            if (actual != expected) index else null
                        }
                    if (mismatches.isNotEmpty()) {
                        return CsvParseResult.Error(
                            "Invalid CSV header: Base columns don't match expected format at positions ${mismatches.joinToString()}. " +
                                    "Expected base: ${BASE_HEADER.joinToString()}, " +
                                    "Found: ${header.take(BASE_HEADER.size).joinToString()}",
                            lineNumber = 1
                        )
                    }
                }

                // Parse data rows
                val records = mutableListOf<SignalRecord>()
                val hasExtendedFields = header.size == EXTENDED_HEADER.size
                for (i in 1 until lines.size) {
                    val line = lines[i].trim()
                    if (line.isEmpty()) continue // Skip empty lines

                    val parseResult = parseRow(line, i + 1, hasExtendedFields)
                    when (parseResult) {
                        is CsvParseResult.Success -> {
                            records.add(parseResult.records.first())
                        }
                        is CsvParseResult.Error -> {
                            return parseResult // Return first error encountered
                        }
                    }
                }

                if (records.isEmpty()) {
                    CsvParseResult.Error("No valid data rows found in CSV file")
                } else {
                    CsvParseResult.Success(records)
                }
            } catch (e: Exception) {
                CsvParseResult.Error("Error reading CSV file: ${e.message}")
            }
        }

        /**
         * Parses a single CSV row.
         */
        private fun parseRow(line: String, lineNumber: Int, hasExtendedFields: Boolean): CsvParseResult {
            try {
                // Handle quoted fields and commas within quotes
                val fields = parseCsvLine(line)

                val expectedSize = if (hasExtendedFields) EXTENDED_HEADER.size else BASE_HEADER.size
                if (fields.size != expectedSize) {
                    return CsvParseResult.Error(
                        "Invalid row: Expected $expectedSize columns, found ${fields.size}",
                        lineNumber = lineNumber
                    )
                }

                // Parse timestamp (epoch milliseconds)
                val timestamp = try {
                    Instant.ofEpochMilli(fields[0].toLong())
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid timestamp format at line $lineNumber: ${fields[0]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse latitude
                val latitude = try {
                    fields[1].toDouble()
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid latitude at line $lineNumber: ${fields[1]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse longitude
                val longitude = try {
                    fields[2].toDouble()
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid longitude at line $lineNumber: ${fields[2]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse altitude
                val altitude = try {
                    fields[3].toDoubleOrNull() ?: 0.0
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid altitude at line $lineNumber: ${fields[3]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse signal strength
                val signalStrength = try {
                    fields[4].toInt()
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid signal strength at line $lineNumber: ${fields[4]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse cell ID
                val cellId = try {
                    fields[5].toInt()
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid cell ID at line $lineNumber: ${fields[5]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse data rate
                val dataRateKbps = try {
                    fields[6].toInt()
                } catch (e: Exception) {
                    return CsvParseResult.Error(
                        "Invalid data rate at line $lineNumber: ${fields[6]}",
                        lineNumber = lineNumber
                    )
                }

                // Parse network type (string)
                val networkType = fields[7]

                // Parse ASU
                val asu = try {
                    fields[8].toIntOrNull() ?: 0
                } catch (e: Exception) {
                    0
                }

                // Parse remaining fields
                val dataState = fields[9].ifEmpty { "Unknown" }
                val dataActivity = fields[10].ifEmpty { "None" }
                val isRoaming = try {
                    fields[11].toBoolean()
                } catch (e: Exception) {
                    fields[11].lowercase() == "true"
                }
                val simState = fields[12].ifEmpty { "Unknown" }
                val simOperatorName = fields[13].removeSurrounding("\"")
                val simMcc = fields[14]
                val simMnc = fields[15]
                val operatorName = fields[16].removeSurrounding("\"")
                val mcc = fields[17]
                val mnc = fields[18]
                val phoneType = fields[19].ifEmpty { "Unknown" }
                val simSlotIndex = try {
                    fields[20].toIntOrNull() ?: 0
                } catch (e: Exception) {
                    0
                }
                val subscriptionId = try {
                    fields[21].toIntOrNull() ?: -1
                } catch (e: Exception) {
                    -1
                }
                val simDisplayName = fields[22].removeSurrounding("\"")
                val isEmbedded = try {
                    fields[23].toBoolean()
                } catch (e: Exception) {
                    fields[23].lowercase() == "true"
                }

                // Parse extended fields if available, otherwise use defaults
                val ci = if (hasExtendedFields && fields.size > 24) {
                    fields[24].toIntOrNull() ?: 0
                } else 0
                val enb = if (hasExtendedFields && fields.size > 25) {
                    fields[25].toIntOrNull() ?: 0
                } else 0
                val tac = if (hasExtendedFields && fields.size > 26) {
                    fields[26].toIntOrNull() ?: 0
                } else 0
                val pci = if (hasExtendedFields && fields.size > 27) {
                    fields[27].toIntOrNull() ?: 0
                } else 0
                val bandwidth = if (hasExtendedFields && fields.size > 28) {
                    fields[28].toIntOrNull() ?: 0
                } else 0
                val earfcn = if (hasExtendedFields && fields.size > 29) {
                    fields[29].toIntOrNull() ?: 0
                } else 0
                val nrarfcn = if (hasExtendedFields && fields.size > 30) {
                    fields[30].toIntOrNull() ?: 0
                } else 0
                val rssi = if (hasExtendedFields && fields.size > 31) {
                    fields[31].toIntOrNull() ?: 0
                } else 0
                val rsrq = if (hasExtendedFields && fields.size > 32) {
                    fields[32].toIntOrNull() ?: 0
                } else 0
                val snr = if (hasExtendedFields && fields.size > 33) {
                    fields[33].toIntOrNull() ?: 0
                } else 0
                val cqi = if (hasExtendedFields && fields.size > 34) {
                    fields[34].toIntOrNull() ?: 0
                } else 0
                val timingAdvance = if (hasExtendedFields && fields.size > 35) {
                    fields[35].toIntOrNull() ?: 0
                } else 0

                val record = SignalRecord(
                    timestamp = timestamp,
                    latitude = latitude,
                    longitude = longitude,
                    altitude = altitude,
                    signalStrength = signalStrength,
                    cellId = cellId,
                    dataRateKbps = dataRateKbps,
                    networkType = networkType,
                    asu = asu,
                    dataState = dataState,
                    dataActivity = dataActivity,
                    isRoaming = isRoaming,
                    simState = simState,
                    simOperatorName = simOperatorName,
                    simMcc = simMcc,
                    simMnc = simMnc,
                    operatorName = operatorName,
                    mcc = mcc,
                    mnc = mnc,
                    phoneType = phoneType,
                    simSlotIndex = simSlotIndex,
                    subscriptionId = subscriptionId,
                    simDisplayName = simDisplayName,
                    isEmbedded = isEmbedded,
                    ci = ci,
                    enb = enb,
                    tac = tac,
                    pci = pci,
                    bandwidth = bandwidth,
                    earfcn = earfcn,
                    nrarfcn = nrarfcn,
                    rssi = rssi,
                    rsrq = rsrq,
                    snr = snr,
                    cqi = cqi,
                    timingAdvance = timingAdvance
                )

                return CsvParseResult.Success(listOf(record))
            } catch (e: Exception) {
                return CsvParseResult.Error(
                    "Error parsing line $lineNumber: ${e.message}",
                    lineNumber = lineNumber
                )
            }
        }

        /**
         * Parses a CSV line handling quoted fields.
         */
        private fun parseCsvLine(line: String): List<String> {
            val fields = mutableListOf<String>()
            var currentField = StringBuilder()
            var insideQuotes = false
            var i = 0

            while (i < line.length) {
                val char = line[i]
                when {
                    char == '"' -> {
                        if (insideQuotes && i + 1 < line.length && line[i + 1] == '"') {
                            // Escaped quote
                            currentField.append('"')
                            i += 2
                        } else {
                            // Toggle quote state
                            insideQuotes = !insideQuotes
                            i++
                        }
                    }
                    char == ',' && !insideQuotes -> {
                        // Field separator
                        fields.add(currentField.toString().trim())
                        currentField.clear()
                        i++
                    }
                    else -> {
                        currentField.append(char)
                        i++
                    }
                }
            }
            // Add last field
            fields.add(currentField.toString().trim())

            return fields
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/data/FileLogger.kt
================
package com.signaldrivelogger.data

import android.content.Context
import com.signaldrivelogger.domain.models.SignalRecord
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileWriter
import java.time.Instant

/**
 * Handles logging SignalRecord data to files (CSV and GPX formats).
 */
class FileLogger(private val context: Context) {
    private val recordsDir: File = File(context.getExternalFilesDir(null), "signal_logs")

    init {
        recordsDir.mkdirs()
    }

    /**
     * Logs a record to CSV file (append mode).
     */
    suspend fun logToCsv(record: SignalRecord, filename: String) = withContext(Dispatchers.IO) {
        val file = File(recordsDir, "$filename.csv")
        val header = "timestamp,latitude,longitude,altitude_m,signal_strength_dbm,cell_id,data_rate_kbps,network_type,asu," +
                "data_state,data_activity,roaming,sim_state,sim_operator_name,sim_mcc,sim_mnc," +
                "operator_name,mcc,mnc,phone_type,sim_slot_index,subscription_id,sim_display_name,is_embedded," +
                "ci,enb,tac,pci,bandwidth_khz,earfcn,nrarfcn,rssi_dbm,rsrq_db,snr_db,cqi,timing_advance\n"

        if (!file.exists()) {
            file.writeText(header)
        }

        file.appendText("${record.toCsvRow()}\n")
    }

    /**
     * Logs a record to GPX file (append mode).
     */
    suspend fun logToGpx(record: SignalRecord, filename: String) = withContext(Dispatchers.IO) {
        val file = File(recordsDir, "$filename.gpx")

        if (!file.exists()) {
            // Write GPX header
            file.writeText("""<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Cell Signal Logger">
    <trk>
        <name>Signal Drive Log</name>
        <trkseg>
""")
        }

        // Append trackpoint
        val trackpoint = record.toGpxTrackpoint()
        file.appendText("            $trackpoint\n")
    }

    /**
     * Finalizes GPX file by closing the XML tags.
     */
    suspend fun finalizeGpx(filename: String) = withContext(Dispatchers.IO) {
        val file = File(recordsDir, "$filename.gpx")
        if (file.exists()) {
            file.appendText("""        </trkseg>
    </trk>
</gpx>
""")
        }
    }

    /**
     * Saves all records to a CSV file.
     */
    suspend fun saveRecordsToCsv(records: List<SignalRecord>, filename: String) = withContext(Dispatchers.IO) {
        val file = File(recordsDir, "$filename.csv")
        val header = "timestamp,latitude,longitude,altitude_m,signal_strength_dbm,cell_id,data_rate_kbps,network_type,asu," +
                "data_state,data_activity,roaming,sim_state,sim_operator_name,sim_mcc,sim_mnc," +
                "operator_name,mcc,mnc,phone_type,sim_slot_index,subscription_id,sim_display_name,is_embedded," +
                "ci,enb,tac,pci,bandwidth_khz,earfcn,nrarfcn,rssi_dbm,rsrq_db,snr_db,cqi,timing_advance\n"

        file.writeText(header)
        records.forEach { record ->
            file.appendText("${record.toCsvRow()}\n")
        }
    }

    /**
     * Saves all records to a GPX file.
     */
    suspend fun saveRecordsToGpx(records: List<SignalRecord>, filename: String) = withContext(Dispatchers.IO) {
        val file = File(recordsDir, "$filename.gpx")

        file.writeText("""<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Cell Signal Logger">
    <trk>
        <name>Signal Drive Log</name>
        <trkseg>
""")

        records.forEach { record ->
            val trackpoint = record.toGpxTrackpoint()
            file.appendText("            $trackpoint\n")
        }

        file.appendText("""        </trkseg>
    </trk>
</gpx>
""")
    }

    /**
     * Gets the file for sharing/export.
     */
    fun getFile(filename: String, format: String): File? {
        val file = File(recordsDir, "$filename.$format")
        return if (file.exists()) file else null
    }

    /**
     * Lists all log files.
     */
    fun listLogFiles(): List<String> {
        return recordsDir.listFiles()?.map { it.name } ?: emptyList()
    }

    /**
     * Reads a CSV file and returns the input stream.
     */
    suspend fun readCsvFile(fileUri: android.net.Uri, context: android.content.Context): java.io.InputStream? {
        return try {
            context.contentResolver.openInputStream(fileUri)
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Reads a CSV file from a File path.
     */
    suspend fun readCsvFile(file: java.io.File): java.io.InputStream? {
        return try {
            if (file.exists() && file.canRead()) {
                file.inputStream()
            } else {
                null
            }
        } catch (e: Exception) {
            null
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/data/LocationProvider.kt
================
package com.signaldrivelogger.data

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import androidx.core.content.ContextCompat
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

/**
 * Provides location updates using FusedLocationProviderClient.
 * Emits Location objects as a Flow.
 */
class LocationProvider(private val context: Context) {
    private val fusedLocationClient: FusedLocationProviderClient =
        LocationServices.getFusedLocationProviderClient(context)

    private var locationCallback: LocationCallback? = null

    /**
     * Checks if location permission is granted.
     */
    fun hasPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Gets the last known location (one-time).
     */
    suspend fun getLastLocation(): Location? {
        if (!hasPermission()) return null
        return try {
            fusedLocationClient.lastLocation.await()
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Starts location updates and emits them as a Flow.
     * Updates every 2 seconds with high accuracy.
     */
    fun getLocationUpdates(): Flow<Location> = callbackFlow {
        if (!hasPermission()) {
            close()
            return@callbackFlow
        }

        val locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            2000L // 2 seconds
        ).apply {
            setMinUpdateIntervalMillis(1000L) // Minimum 1 second
            setMaxUpdateDelayMillis(5000L) // Max delay 5 seconds
        }.build()

        locationCallback = object : LocationCallback() {
            override fun onLocationResult(result: LocationResult) {
                result.lastLocation?.let { location ->
                    trySend(location)
                }
            }
        }

        fusedLocationClient.requestLocationUpdates(
            locationRequest,
            locationCallback!!,
            context.mainLooper
        )

        awaitClose {
            locationCallback?.let {
                fusedLocationClient.removeLocationUpdates(it)
            }
        }
    }

    /**
     * Stops location updates.
     */
    fun stopLocationUpdates() {
        locationCallback?.let {
            fusedLocationClient.removeLocationUpdates(it)
            locationCallback = null
        }
    }
}

// Extension function to await Task result
private suspend fun <T> com.google.android.gms.tasks.Task<T>.await(): T {
    return suspendCancellableCoroutine { cont ->
        addOnCompleteListener { task ->
            if (task.exception != null) {
                cont.resumeWithException(task.exception!!)
            } else {
                @Suppress("UNCHECKED_CAST")
                cont.resume(task.result as T)
            }
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt
================
package com.signaldrivelogger.data

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.telephony.SubscriptionInfo
import android.telephony.SubscriptionManager
import android.telephony.TelephonyManager
import androidx.core.content.ContextCompat
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers

/**
 * Monitors multiple SIM cards (physical + eSIM) and provides signal data for each.
 */
class MultiSimMonitor(private val context: Context) {
    private val subscriptionManager: SubscriptionManager? =
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            context.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE) as? SubscriptionManager
        } else {
            null
        }

    /**
     * Gets all active subscription IDs (SIM cards).
     */
    fun getActiveSubscriptionIds(): List<Int> {
        if (!hasPermission()) return emptyList()

        return try {
            if (subscriptionManager != null && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                val subscriptions = subscriptionManager.activeSubscriptionInfoList
                subscriptions?.mapNotNull { it.subscriptionId } ?: emptyList()
            } else {
                // Fallback: use default subscription (single SIM)
                val defaultSubId = getDefaultSubscriptionId()
                if (defaultSubId >= 0) listOf(defaultSubId) else emptyList()
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    /**
     * Gets subscription info for a given subscription ID.
     */
    fun getSubscriptionInfo(subscriptionId: Int): SubscriptionInfo? {
        if (!hasPermission() || subscriptionManager == null) return null

        return try {
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                subscriptionManager.getActiveSubscriptionInfo(subscriptionId)
            } else {
                null
            }
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Gets TelephonyManager for a specific subscription.
     */
    fun getTelephonyManagerForSubscription(subscriptionId: Int): TelephonyManager? {
        if (!hasPermission()) return null

        return try {
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
                val telephonyManager = context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
                telephonyManager.createForSubscriptionId(subscriptionId)
            } else {
                // Fallback to default
                context.getSystemService(Context.TELEPHONY_SERVICE) as? TelephonyManager
            }
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Gets SIM slot index for a subscription.
     */
    fun getSimSlotIndex(subscriptionId: Int): Int {
        val info = getSubscriptionInfo(subscriptionId) ?: return 0
        return try {
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                info.simSlotIndex
            } else {
                0
            }
        } catch (e: Exception) {
            0
        }
    }

    /**
     * Checks if SIM is embedded (eSIM).
     */
    fun isEmbeddedSim(subscriptionId: Int): Boolean {
        val info = getSubscriptionInfo(subscriptionId) ?: return false
        return try {
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {
                info.isEmbedded
            } else {
                // Heuristic: eSIM typically has slot index >= phone slot count
                val slotIndex = getSimSlotIndex(subscriptionId)
                val phoneCount = getPhoneCount()
                slotIndex >= phoneCount
            }
        } catch (e: Exception) {
            false
        }
    }

    /**
     * Gets display name for a subscription.
     */
    fun getSimDisplayName(subscriptionId: Int): String {
        val info = getSubscriptionInfo(subscriptionId) ?: return "SIM $subscriptionId"
        return try {
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                info.displayName?.toString() ?: "SIM ${info.simSlotIndex + 1}"
            } else {
                "SIM 1"
            }
        } catch (e: Exception) {
            "SIM $subscriptionId"
        }
    }

    /**
     * Gets all signal data updates from all SIMs as a Flow.
     * Each SIM emits its own SignalData with subscription ID.
     */
    fun getAllSimSignalUpdates(): Flow<SimSignalData> = callbackFlow {
        if (!hasPermission()) {
            close()
            return@callbackFlow
        }

        val subscriptionIds = getActiveSubscriptionIds()
        val monitors = mutableListOf<TelephonyMonitorForSubscription>()
        val jobs = mutableListOf<kotlinx.coroutines.Job>()

        // Use a coroutine scope for launching collection jobs
        val scope = CoroutineScope(Dispatchers.Main)

        if (subscriptionIds.isEmpty()) {
            // Fallback: monitor default SIM
            val defaultSubId = getDefaultSubscriptionId()
            if (defaultSubId >= 0) {
                val monitor = TelephonyMonitorForSubscription(context, defaultSubId, this@MultiSimMonitor)
                monitors.add(monitor)
                val job = scope.launch {
                    monitor.getSignalStrengthUpdates().collect { signalData ->
                        trySend(SimSignalData(defaultSubId, signalData))
                    }
                }
                jobs.add(job)
            } else {
                close()
                return@callbackFlow
            }
        } else {
            // Monitor all SIMs
            subscriptionIds.forEach { subId ->
                val monitor = TelephonyMonitorForSubscription(context, subId, this@MultiSimMonitor)
                monitors.add(monitor)

                // Launch collection for each SIM
                val job = scope.launch {
                    monitor.getSignalStrengthUpdates().collect { signalData ->
                        trySend(SimSignalData(subId, signalData))
                    }
                }
                jobs.add(job)
            }
        }

        awaitClose {
            jobs.forEach { it.cancel() }
            monitors.forEach { it.stopMonitoring() }
        }
    }

    private fun getDefaultSubscriptionId(): Int {
        return try {
            if (subscriptionManager != null && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                val activeSubs = subscriptionManager.activeSubscriptionInfoList
                activeSubs?.firstOrNull()?.subscriptionId ?: -1
            } else {
                -1
            }
        } catch (e: Exception) {
            -1
        }
    }

    private fun getPhoneCount(): Int {
        return try {
            val telephonyManager = context.getSystemService(Context.TELEPHONY_SERVICE) as? TelephonyManager
            telephonyManager?.phoneCount ?: 1
        } catch (e: Exception) {
            1
        }
    }

    fun hasPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.READ_PHONE_STATE
        ) == PackageManager.PERMISSION_GRANTED
    }
}

/**
 * Signal data with subscription ID.
 */
data class SimSignalData(
    val subscriptionId: Int,
    val signalData: SignalData
)

/**
 * TelephonyMonitor for a specific subscription.
 */
private class TelephonyMonitorForSubscription(
    private val context: Context,
    val subscriptionId: Int,
    private val multiSimMonitor: MultiSimMonitor
) {
    private val telephonyManager: TelephonyManager? = multiSimMonitor.getTelephonyManagerForSubscription(subscriptionId)

    fun getSignalStrengthUpdates(): Flow<SignalData> = callbackFlow {
        if (telephonyManager == null) {
            close()
            return@callbackFlow
        }

        val handler = android.os.Handler(context.mainLooper)
        var updateRunnable: Runnable? = null

        fun emitSignalData() {
            val cellInfo = getCurrentCellInfo()
            val signalStrength = getCurrentSignalStrength() ?: return
            val cellId = getCurrentCellId() ?: 0
            val networkType = getCurrentNetworkType()

            // Extract detailed cell information
            val (ci, enb, tac, pci, bandwidth, earfcn, nrarfcn, rssi, rsrq, snr, cqi, timingAdvance) =
                extractCellDetails(cellInfo)

            val signalData = SignalData(
                signalStrength = signalStrength,
                cellId = cellId,
                networkType = networkType,
                dataState = getDataState(),
                dataActivity = getDataActivity(),
                isRoaming = telephonyManager.isNetworkRoaming,
                simState = getSimState(),
                simOperatorName = getSimOperatorName(),
                simMcc = getSimMcc(),
                simMnc = getSimMnc(),
                operatorName = getOperatorName(),
                mcc = getMcc(),
                mnc = getMnc(),
                phoneType = getPhoneType(),
                ci = ci,
                enb = enb,
                tac = tac,
                pci = pci,
                bandwidth = bandwidth,
                earfcn = earfcn,
                nrarfcn = nrarfcn,
                rssi = rssi,
                rsrq = rsrq,
                snr = snr,
                cqi = cqi,
                timingAdvance = timingAdvance
            )

            trySend(signalData)
        }

        // Initial emit
        emitSignalData()

        // Use periodic polling for multi-SIM support (more reliable than PhoneStateListener)
        // PhoneStateListener with subscription ID has API compatibility issues
        updateRunnable = object : Runnable {
            override fun run() {
                emitSignalData()
                handler.postDelayed(this, 2000)
            }
        }
        handler.post(updateRunnable)

        awaitClose {
            updateRunnable?.let { handler.removeCallbacks(it) }
        }
    }

    fun stopMonitoring() {
        // Cleanup handled by awaitClose
    }

    private fun getCurrentSignalStrength(): Int? {
        return try {
            val cellInfoList = telephonyManager?.allCellInfo
            cellInfoList?.firstOrNull()?.let { cellInfo ->
                when (cellInfo) {
                    is android.telephony.CellInfoLte -> {
                        val signalStrength = cellInfo.cellSignalStrength as android.telephony.CellSignalStrengthLte
                        signalStrength.rsrp
                    }
                    is android.telephony.CellInfoNr -> {
                        val signalStrength = cellInfo.cellSignalStrength as android.telephony.CellSignalStrengthNr
                        signalStrength.csiRsrp
                    }
                    else -> null
                }
            } ?: run {
                val signalStrength = telephonyManager?.signalStrength
                signalStrength?.let { convertToDbm(it) }
            }
        } catch (e: Exception) {
            null
        }
    }

    private fun getCurrentCellId(): Int? {
        return try {
            // Try to get from CellInfo first (more accurate)
            val cellInfo = getCurrentCellInfo()
            when (cellInfo) {
                is android.telephony.CellInfoLte -> {
                    val cellIdentity = cellInfo.cellIdentity as android.telephony.CellIdentityLte
                    val ci = cellIdentity.ci
                    if (ci != android.telephony.CellInfo.UNAVAILABLE) ci else null
                }
                is android.telephony.CellInfoNr -> {
                    val cellIdentity = cellInfo.cellIdentity as android.telephony.CellIdentityNr
                    val nci = cellIdentity.nci
                    val unavailableLong = android.telephony.CellInfo.UNAVAILABLE.toLong()
                    if (nci != unavailableLong) nci.toInt() else null
                }
                else -> {
                    // Fallback to cellLocation
                    val cellLocation = telephonyManager?.cellLocation
                    when (cellLocation) {
                        is android.telephony.gsm.GsmCellLocation -> cellLocation.cid
                        is android.telephony.cdma.CdmaCellLocation -> cellLocation.baseStationId
                        else -> null
                    }
                }
            }
        } catch (e: Exception) {
            null
        }
    }

    private fun getCurrentCellInfo(): android.telephony.CellInfo? {
        return try {
            telephonyManager?.allCellInfo?.firstOrNull()
        } catch (e: Exception) {
            null
        }
    }

    private fun extractCellDetails(cellInfo: android.telephony.CellInfo?): CellDetails {
        if (cellInfo == null) {
            return CellDetails(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }

        return try {
            when (cellInfo) {
                is android.telephony.CellInfoLte -> {
                    val cellIdentity = cellInfo.cellIdentity as android.telephony.CellIdentityLte
                    val signalStrength = cellInfo.cellSignalStrength as android.telephony.CellSignalStrengthLte

                    // Calculate eNodeB ID from CI (Cell Identity)
                    // eNodeB ID is the upper 20 bits of the 28-bit CI
                    val ci = if (cellIdentity.ci != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.ci else 0
                    val enb = if (ci != 0) (ci shr 8) else 0 // Extract upper 20 bits (shift right by 8 bits)

                    CellDetails(
                        ci = ci,
                        enb = enb,
                        tac = if (cellIdentity.tac != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.tac else 0,
                        pci = if (cellIdentity.pci != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.pci else 0,
                        bandwidth = if (cellIdentity.bandwidth != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.bandwidth else 0,
                        earfcn = if (cellIdentity.earfcn != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.earfcn else 0,
                        nrarfcn = 0, // Not applicable for LTE
                        rssi = if (signalStrength.rssi != android.telephony.CellInfo.UNAVAILABLE) signalStrength.rssi else 0,
                        rsrq = if (signalStrength.rsrq != android.telephony.CellInfo.UNAVAILABLE) signalStrength.rsrq else 0,
                        snr = if (signalStrength.rssnr != android.telephony.CellInfo.UNAVAILABLE) signalStrength.rssnr else 0,
                        cqi = if (signalStrength.cqi != android.telephony.CellInfo.UNAVAILABLE) signalStrength.cqi else 0,
                        timingAdvance = if (signalStrength.timingAdvance != android.telephony.CellInfo.UNAVAILABLE) signalStrength.timingAdvance else 0
                    )
                }
                is android.telephony.CellInfoNr -> {
                    val cellIdentity = cellInfo.cellIdentity as android.telephony.CellIdentityNr
                    val signalStrength = cellInfo.cellSignalStrength as android.telephony.CellSignalStrengthNr

                    val unavailableLong = android.telephony.CellInfo.UNAVAILABLE.toLong()

                    CellDetails(
                        ci = if (cellIdentity.nci != unavailableLong) cellIdentity.nci.toInt() else 0,
                        enb = 0, // Not applicable for 5G NR
                        tac = if (cellIdentity.tac != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.tac else 0,
                        pci = if (cellIdentity.pci != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.pci else 0,
                        bandwidth = 0, // Not directly available in CellInfoNr
                        earfcn = 0, // Not applicable for 5G NR
                        nrarfcn = if (cellIdentity.nrarfcn != android.telephony.CellInfo.UNAVAILABLE) cellIdentity.nrarfcn else 0,
                        rssi = 0, // Not directly available in CellSignalStrengthNr
                        rsrq = if (signalStrength.csiRsrq != android.telephony.CellInfo.UNAVAILABLE) signalStrength.csiRsrq else 0,
                        snr = if (signalStrength.csiSinr != android.telephony.CellInfo.UNAVAILABLE) signalStrength.csiSinr else 0,
                        cqi = 0, // Not directly available in CellSignalStrengthNr
                        timingAdvance = 0 // Not directly available in CellSignalStrengthNr
                    )
                }
                else -> CellDetails(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        } catch (e: Exception) {
            CellDetails(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }
    }

    private data class CellDetails(
        val ci: Int,
        val enb: Int,
        val tac: Int,
        val pci: Int,
        val bandwidth: Int,
        val earfcn: Int,
        val nrarfcn: Int,
        val rssi: Int,
        val rsrq: Int,
        val snr: Int,
        val cqi: Int,
        val timingAdvance: Int
    )

    private fun getCurrentNetworkType(): String {
        return try {
            val networkType = telephonyManager?.dataNetworkType ?: TelephonyManager.NETWORK_TYPE_UNKNOWN
            when (networkType) {
                TelephonyManager.NETWORK_TYPE_LTE -> "LTE"
                TelephonyManager.NETWORK_TYPE_NR -> "5G"
                TelephonyManager.NETWORK_TYPE_HSPAP -> "HSPA+"
                TelephonyManager.NETWORK_TYPE_HSPA -> "HSPA"
                TelephonyManager.NETWORK_TYPE_UMTS -> "3G"
                TelephonyManager.NETWORK_TYPE_EDGE -> "EDGE"
                TelephonyManager.NETWORK_TYPE_GPRS -> "GPRS"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    private fun getDataState(): String {
        return try {
            when (telephonyManager?.dataState) {
                TelephonyManager.DATA_CONNECTED -> "Connected"
                TelephonyManager.DATA_CONNECTING -> "Connecting"
                TelephonyManager.DATA_DISCONNECTED -> "Disconnected"
                TelephonyManager.DATA_SUSPENDED -> "Suspended"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    private fun getDataActivity(): String {
        return try {
            when (telephonyManager?.dataActivity) {
                TelephonyManager.DATA_ACTIVITY_IN -> "In"
                TelephonyManager.DATA_ACTIVITY_OUT -> "Out"
                TelephonyManager.DATA_ACTIVITY_INOUT -> "InOut"
                TelephonyManager.DATA_ACTIVITY_DORMANT -> "Dormant"
                else -> "None"
            }
        } catch (e: Exception) {
            "None"
        }
    }

    private fun getSimState(): String {
        return try {
            when (telephonyManager?.simState) {
                TelephonyManager.SIM_STATE_READY -> "Ready"
                TelephonyManager.SIM_STATE_ABSENT -> "Absent"
                TelephonyManager.SIM_STATE_PIN_REQUIRED -> "PIN Required"
                TelephonyManager.SIM_STATE_PUK_REQUIRED -> "PUK Required"
                TelephonyManager.SIM_STATE_NETWORK_LOCKED -> "Network Locked"
                TelephonyManager.SIM_STATE_UNKNOWN -> "Unknown"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    private fun getSimOperatorName(): String {
        return try {
            telephonyManager?.simOperatorName ?: ""
        } catch (e: Exception) {
            ""
        }
    }

    private fun getSimMcc(): String {
        return try {
            val simOperator = telephonyManager?.simOperator ?: ""
            if (simOperator.length >= 3) simOperator.substring(0, 3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    private fun getSimMnc(): String {
        return try {
            val simOperator = telephonyManager?.simOperator ?: ""
            if (simOperator.length > 3) simOperator.substring(3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    private fun getOperatorName(): String {
        return try {
            telephonyManager?.networkOperatorName ?: ""
        } catch (e: Exception) {
            ""
        }
    }

    private fun getMcc(): String {
        return try {
            val networkOperator = telephonyManager?.networkOperator ?: ""
            if (networkOperator.length >= 3) networkOperator.substring(0, 3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    private fun getMnc(): String {
        return try {
            val networkOperator = telephonyManager?.networkOperator ?: ""
            if (networkOperator.length > 3) networkOperator.substring(3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    private fun getPhoneType(): String {
        return try {
            when (telephonyManager?.phoneType) {
                TelephonyManager.PHONE_TYPE_GSM -> "GSM"
                TelephonyManager.PHONE_TYPE_CDMA -> "CDMA"
                TelephonyManager.PHONE_TYPE_SIP -> "SIP"
                TelephonyManager.PHONE_TYPE_NONE -> "None"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    private fun convertToDbm(signalStrength: android.telephony.SignalStrength): Int? {
        return try {
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {
                signalStrength.cellSignalStrengths.firstOrNull()?.let {
                    when (it) {
                        is android.telephony.CellSignalStrengthLte -> it.rsrp
                        is android.telephony.CellSignalStrengthNr -> it.csiRsrp
                        else -> null
                    }
                }
            } else {
                val asu = signalStrength.gsmSignalStrength
                if (asu != 99 && asu != -1) {
                    -113 + (2 * asu)
                } else null
            }
        } catch (e: Exception) {
            null
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/data/SignalRepository.kt
================
package com.signaldrivelogger.data

import android.location.Location
import com.signaldrivelogger.domain.models.SignalRecord
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.time.Instant

/**
 * Repository that combines location and signal data into SignalRecord objects.
 */
class SignalRepository(
    private val locationProvider: LocationProvider,
    private val telephonyMonitor: TelephonyMonitor,
    private val fileLogger: FileLogger
) {
    private val _records = MutableStateFlow<List<SignalRecord>>(emptyList())
    val records: StateFlow<List<SignalRecord>> = _records.asStateFlow()

    private val _isLogging = MutableStateFlow(false)
    val isLogging: StateFlow<Boolean> = _isLogging.asStateFlow()

    private var currentFilename: String = "signal_log_${System.currentTimeMillis()}"

    /**
     * Starts logging by combining location and signal updates.
     */
    fun startLogging(filename: String? = null) {
        if (_isLogging.value) return

        currentFilename = filename ?: "signal_log_${System.currentTimeMillis()}"
        _isLogging.value = true
    }

    /**
     * Stops logging.
     */
    fun stopLogging() {
        _isLogging.value = false
    }

    /**
     * Creates a SignalRecord from location and signal data.
     */
    suspend fun createRecord(
        location: Location,
        signalData: com.signaldrivelogger.data.SignalData,
        dataRate: Int,
        simSlotIndex: Int = 0,
        subscriptionId: Int = -1,
        simDisplayName: String = "",
        isEmbedded: Boolean = false
    ): SignalRecord? {
        val strength = signalData.signalStrength

        return SignalRecord(
            timestamp = Instant.now(),
            latitude = location.latitude,
            longitude = location.longitude,
            altitude = location.altitude, // GPS altitude in meters
            signalStrength = strength,
            cellId = signalData.cellId,
            dataRateKbps = dataRate,
            networkType = signalData.networkType,
            dataState = signalData.dataState,
            dataActivity = signalData.dataActivity,
            isRoaming = signalData.isRoaming,
            simState = signalData.simState,
            simOperatorName = signalData.simOperatorName,
            simMcc = signalData.simMcc,
            simMnc = signalData.simMnc,
            operatorName = signalData.operatorName,
            mcc = signalData.mcc,
            mnc = signalData.mnc,
            phoneType = signalData.phoneType,
            simSlotIndex = simSlotIndex,
            subscriptionId = subscriptionId,
            simDisplayName = simDisplayName,
            isEmbedded = isEmbedded,
            ci = signalData.ci,
            enb = signalData.enb,
            tac = signalData.tac,
            pci = signalData.pci,
            bandwidth = signalData.bandwidth,
            earfcn = signalData.earfcn,
            nrarfcn = signalData.nrarfcn,
            rssi = signalData.rssi,
            rsrq = signalData.rsrq,
            snr = signalData.snr,
            cqi = signalData.cqi,
            timingAdvance = signalData.timingAdvance
        )
    }

    /**
     * Adds a record to the list and logs it to file.
     */
    suspend fun addRecord(record: SignalRecord) {
        _records.value = _records.value + record

        if (_isLogging.value) {
            // Log to both CSV and GPX
            fileLogger.logToCsv(record, currentFilename)
            fileLogger.logToGpx(record, currentFilename)
        }
    }

    /**
     * Saves all records to file.
     */
    suspend fun saveRecords(filename: String, format: String = "csv") {
        val records = _records.value
        when (format.lowercase()) {
            "csv" -> fileLogger.saveRecordsToCsv(records, filename)
            "gpx" -> {
                fileLogger.saveRecordsToGpx(records, filename)
            }
        }
    }

    /**
     * Clears all records from memory.
     */
    fun clearRecords() {
        _records.value = emptyList()
    }

    /**
     * Gets the current filename.
     */
    fun getCurrentFilename(): String = currentFilename

    /**
     * Sets the filename for logging.
     */
    fun setFilename(filename: String) {
        currentFilename = filename
    }

    /**
     * Imports records from a CSV file and appends them to existing records.
     */
    suspend fun importFromCsv(inputStream: java.io.InputStream): Result<String> {
        return try {
            val parseResult = com.signaldrivelogger.data.CsvParser.parse(inputStream)
            when (parseResult) {
                is com.signaldrivelogger.data.CsvParseResult.Success -> {
                    // Append imported records to existing ones
                    _records.value = _records.value + parseResult.records
                    Result.success("Successfully imported ${parseResult.records.size} records")
                }
                is com.signaldrivelogger.data.CsvParseResult.Error -> {
                    Result.failure(Exception(parseResult.message))
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        } finally {
            inputStream.close()
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/data/TelephonyMonitor.kt
================
package com.signaldrivelogger.data

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.telephony.CellInfo
import android.telephony.CellInfoLte
import android.telephony.CellInfoNr
import android.telephony.CellSignalStrengthLte
import android.telephony.CellSignalStrengthNr
import android.telephony.PhoneStateListener
import android.telephony.SignalStrength
import android.telephony.TelephonyManager
import android.telephony.cdma.CdmaCellLocation
import android.telephony.gsm.GsmCellLocation
import androidx.core.content.ContextCompat
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Monitors telephony signal strength and cell information.
 * Provides signal data as a Flow.
 */
class TelephonyMonitor(private val context: Context) {
    private val telephonyManager: TelephonyManager =
        context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager

    private val _currentSignalStrength = MutableStateFlow<Int?>(null)
    val currentSignalStrength: StateFlow<Int?> = _currentSignalStrength.asStateFlow()

    private val _currentCellId = MutableStateFlow<Int?>(null)
    val currentCellId: StateFlow<Int?> = _currentCellId.asStateFlow()

    private val _currentNetworkType = MutableStateFlow<String>("Unknown")
    val currentNetworkType: StateFlow<String> = _currentNetworkType.asStateFlow()

    private var signalStrengthCallback: Any? = null // SignalStrengthCallback for API 31+
    private var phoneStateListener: PhoneStateListener? = null

    /**
     * Checks if phone state permission is granted.
     */
    fun hasPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.READ_PHONE_STATE
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Gets current signal strength in dBm (RSRP for LTE/5G).
     */
    fun getCurrentSignalStrength(): Int? {
        if (!hasPermission()) return null

        return try {
            val cellInfoList = telephonyManager.allCellInfo
            cellInfoList?.firstOrNull()?.let { cellInfo ->
                when (cellInfo) {
                    is CellInfoLte -> {
                        val signalStrength = cellInfo.cellSignalStrength as CellSignalStrengthLte
                        signalStrength.rsrp
                    }
                    is CellInfoNr -> {
                        val signalStrength = cellInfo.cellSignalStrength as CellSignalStrengthNr
                        signalStrength.csiRsrp
                    }
                    else -> null
                }
            } ?: run {
                // Fallback: try to get from SignalStrength
                val signalStrength = telephonyManager.signalStrength
                signalStrength?.let { convertToDbm(it) }
            }
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Gets current cell ID.
     */
    fun getCurrentCellId(): Int? {
        if (!hasPermission()) return null

        return try {
            val cellLocation = telephonyManager.cellLocation
            when (cellLocation) {
                is GsmCellLocation -> cellLocation.cid
                is CdmaCellLocation -> cellLocation.baseStationId
                else -> null
            }
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Gets current network type as string (4G, 5G, LTE, etc.).
     */
    fun getCurrentNetworkType(): String {
        if (!hasPermission()) return "Unknown"

        return try {
            val networkType = telephonyManager.dataNetworkType
            when (networkType) {
                TelephonyManager.NETWORK_TYPE_LTE -> "LTE"
                TelephonyManager.NETWORK_TYPE_NR -> "5G"
                TelephonyManager.NETWORK_TYPE_HSPAP -> "HSPA+"
                TelephonyManager.NETWORK_TYPE_HSPA -> "HSPA"
                TelephonyManager.NETWORK_TYPE_UMTS -> "3G"
                TelephonyManager.NETWORK_TYPE_EDGE -> "EDGE"
                TelephonyManager.NETWORK_TYPE_GPRS -> "GPRS"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    /**
     * Starts monitoring signal strength and emits updates as a Flow.
     */
    fun getSignalStrengthUpdates(): Flow<SignalData> = callbackFlow {
        if (!hasPermission()) {
            close()
            return@callbackFlow
        }

        val handler = android.os.Handler(context.mainLooper)
        var updateRunnable: Runnable? = null

        // Function to emit signal data
        fun emitSignalData() {
            val signalStrength = getCurrentSignalStrength() ?: _currentSignalStrength.value
            val cellId = getCurrentCellId()
            val networkType = getCurrentNetworkType()

            _currentSignalStrength.value = signalStrength
            _currentCellId.value = cellId
            _currentNetworkType.value = networkType

            // Emit to flow if we have valid data with all cell details
            signalStrength?.let {
                trySend(getAllCellDetails())
            }
        }

        // Update initial values
        emitSignalData()

        // Use PhoneStateListener for all Android versions
        // Note: SignalStrengthCallback (API 31+) requires different approach, using PhoneStateListener for compatibility
        phoneStateListener = object : PhoneStateListener() {
            override fun onSignalStrengthsChanged(signalStrength: SignalStrength) {
                val dbm = convertToDbm(signalStrength)
                _currentSignalStrength.value = dbm
                emitSignalData()
            }
        }
        telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS)

        // Periodically emit updates
        updateRunnable = object : Runnable {
            override fun run() {
                emitSignalData()
                handler.postDelayed(this, 2000) // Every 2 seconds
            }
        }
        handler.post(updateRunnable)

        awaitClose {
            updateRunnable?.let { handler.removeCallbacks(it) }
            phoneStateListener?.let {
                telephonyManager.listen(it, PhoneStateListener.LISTEN_NONE)
            }
        }
    }

    /**
     * Converts SignalStrength to dBm (approximate).
     */
    private fun convertToDbm(signalStrength: SignalStrength): Int? {
        return try {
            // Try to get RSRP directly if available
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {
                signalStrength.cellSignalStrengths.firstOrNull()?.let {
                    when (it) {
                        is CellSignalStrengthLte -> it.rsrp
                        is CellSignalStrengthNr -> it.csiRsrp
                        else -> null
                    }
                }
            } else {
                // Fallback: approximate conversion from ASU
                val asu = signalStrength.gsmSignalStrength
                if (asu != 99 && asu != -1) {
                    -113 + (2 * asu) // Approximate conversion
                } else null
            }
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Gets data state as string.
     */
    fun getDataState(): String {
        if (!hasPermission()) return "Unknown"
        return try {
            when (telephonyManager.dataState) {
                TelephonyManager.DATA_CONNECTED -> "Connected"
                TelephonyManager.DATA_CONNECTING -> "Connecting"
                TelephonyManager.DATA_DISCONNECTED -> "Disconnected"
                TelephonyManager.DATA_SUSPENDED -> "Suspended"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    /**
     * Gets data activity as string.
     */
    fun getDataActivity(): String {
        if (!hasPermission()) return "None"
        return try {
            when (telephonyManager.dataActivity) {
                TelephonyManager.DATA_ACTIVITY_IN -> "In"
                TelephonyManager.DATA_ACTIVITY_OUT -> "Out"
                TelephonyManager.DATA_ACTIVITY_INOUT -> "InOut"
                TelephonyManager.DATA_ACTIVITY_DORMANT -> "Dormant"
                else -> "None"
            }
        } catch (e: Exception) {
            "None"
        }
    }

    /**
     * Gets SIM state as string.
     */
    fun getSimState(): String {
        if (!hasPermission()) return "Unknown"
        return try {
            when (telephonyManager.simState) {
                TelephonyManager.SIM_STATE_READY -> "Ready"
                TelephonyManager.SIM_STATE_ABSENT -> "Absent"
                TelephonyManager.SIM_STATE_PIN_REQUIRED -> "PIN Required"
                TelephonyManager.SIM_STATE_PUK_REQUIRED -> "PUK Required"
                TelephonyManager.SIM_STATE_NETWORK_LOCKED -> "Network Locked"
                TelephonyManager.SIM_STATE_UNKNOWN -> "Unknown"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    /**
     * Gets SIM operator name.
     */
    fun getSimOperatorName(): String {
        if (!hasPermission()) return ""
        return try {
            telephonyManager.simOperatorName ?: ""
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Gets SIM MCC.
     */
    fun getSimMcc(): String {
        if (!hasPermission()) return ""
        return try {
            val simOperator = telephonyManager.simOperator
            if (simOperator.length >= 3) simOperator.substring(0, 3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Gets SIM MNC.
     */
    fun getSimMnc(): String {
        if (!hasPermission()) return ""
        return try {
            val simOperator = telephonyManager.simOperator
            if (simOperator.length > 3) simOperator.substring(3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Gets network operator name.
     */
    fun getOperatorName(): String {
        if (!hasPermission()) return ""
        return try {
            telephonyManager.networkOperatorName ?: ""
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Gets network MCC.
     */
    fun getMcc(): String {
        if (!hasPermission()) return ""
        return try {
            val networkOperator = telephonyManager.networkOperator
            if (networkOperator.length >= 3) networkOperator.substring(0, 3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Gets network MNC.
     */
    fun getMnc(): String {
        if (!hasPermission()) return ""
        return try {
            val networkOperator = telephonyManager.networkOperator
            if (networkOperator.length > 3) networkOperator.substring(3) else ""
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Gets phone type as string.
     */
    fun getPhoneType(): String {
        if (!hasPermission()) return "Unknown"
        return try {
            when (telephonyManager.phoneType) {
                TelephonyManager.PHONE_TYPE_GSM -> "GSM"
                TelephonyManager.PHONE_TYPE_CDMA -> "CDMA"
                TelephonyManager.PHONE_TYPE_SIP -> "SIP"
                TelephonyManager.PHONE_TYPE_NONE -> "None"
                else -> "Unknown"
            }
        } catch (e: Exception) {
            "Unknown"
        }
    }

    /**
     * Gets all cell details as SignalData.
     */
    fun getAllCellDetails(): SignalData {
        val signalStrength = getCurrentSignalStrength() ?: -100
        val cellId = getCurrentCellId() ?: 0
        val networkType = getCurrentNetworkType()

        return SignalData(
            signalStrength = signalStrength,
            cellId = cellId,
            networkType = networkType,
            dataState = getDataState(),
            dataActivity = getDataActivity(),
            isRoaming = telephonyManager.isNetworkRoaming,
            simState = getSimState(),
            simOperatorName = getSimOperatorName(),
            simMcc = getSimMcc(),
            simMnc = getSimMnc(),
            operatorName = getOperatorName(),
            mcc = getMcc(),
            mnc = getMnc(),
            phoneType = getPhoneType()
        )
    }

    /**
     * Estimates data rate in Kbps (simplified).
     */
    fun estimateDataRate(): Int {
        val networkType = getCurrentNetworkType()
        val signalStrength = _currentSignalStrength.value ?: -100

        return when (networkType) {
            "5G" -> {
                when {
                    signalStrength > -70 -> 50000 // Strong 5G
                    signalStrength > -90 -> 30000 // Medium 5G
                    else -> 10000 // Weak 5G
                }
            }
            "LTE", "4G" -> {
                when {
                    signalStrength > -70 -> 20000 // Strong LTE
                    signalStrength > -90 -> 10000 // Medium LTE
                    else -> 5000 // Weak LTE
                }
            }
            "HSPA+", "HSPA" -> 5000
            "3G" -> 2000
            else -> 1000
        }
    }

    /**
     * Stops monitoring.
     */
    fun stopMonitoring() {
        phoneStateListener?.let {
            telephonyManager.listen(it, PhoneStateListener.LISTEN_NONE)
        }
        signalStrengthCallback = null
        phoneStateListener = null
    }
}

/**
 * Data class for signal information with extended cell details.
 */
data class SignalData(
    val signalStrength: Int, // RSRP in dBm
    val cellId: Int,
    val networkType: String,
    val dataState: String = "Unknown",
    val dataActivity: String = "None",
    val isRoaming: Boolean = false,
    val simState: String = "Unknown",
    val simOperatorName: String = "",
    val simMcc: String = "",
    val simMnc: String = "",
    val operatorName: String = "",
    val mcc: String = "",
    val mnc: String = "",
    val phoneType: String = "Unknown",
    // LTE/5G cell details
    val ci: Int = 0, // Cell Identity
    val enb: Int = 0, // eNodeB ID
    val tac: Int = 0, // Tracking Area Code
    val pci: Int = 0, // Physical Cell ID
    val bandwidth: Int = 0, // Bandwidth in kHz
    val earfcn: Int = 0, // E-UTRA Absolute Radio Frequency Channel Number (LTE)
    val nrarfcn: Int = 0, // NR Absolute Radio Frequency Channel Number (5G)
    val rssi: Int = 0, // Received Signal Strength Indicator in dBm
    val rsrq: Int = 0, // Reference Signal Received Quality in dB
    val snr: Int = 0, // Signal-to-Noise Ratio in dB
    val cqi: Int = 0, // Channel Quality Indicator
    val timingAdvance: Int = 0 // Timing Advance
)

================
File: app/src/main/java/com/signaldrivelogger/domain/models/SignalRecord.kt
================
package com.signaldrivelogger.domain.models

import java.time.Instant

/**
 * Represents a single signal measurement record with location and telephony data.
 */
data class SignalRecord(
    val timestamp: Instant,
    val latitude: Double,
    val longitude: Double,
    val altitude: Double = 0.0, // GPS altitude in meters
    val signalStrength: Int, // RSRP in dBm (negative value, e.g., -85)
    val cellId: Int,
    val dataRateKbps: Int, // Estimated data rate in Kbps
    val networkType: String, // "4G", "5G", "LTE", etc.
    val asu: Int = 0, // Additional Signal Unit (optional)
    // Extended cell details
    val dataState: String = "Unknown", // Connected, Disconnected, etc.
    val dataActivity: String = "None", // None, Up, Down, InOut
    val isRoaming: Boolean = false,
    val simState: String = "Unknown", // Ready, Absent, etc.
    val simOperatorName: String = "",
    val simMcc: String = "",
    val simMnc: String = "",
    val operatorName: String = "",
    val mcc: String = "",
    val mnc: String = "",
    val phoneType: String = "Unknown", // GSM, CDMA, etc.
    // Multi-SIM support
    val simSlotIndex: Int = 0, // 0, 1, 2, etc.
    val subscriptionId: Int = -1, // Subscription ID
    val simDisplayName: String = "", // Display name for the SIM
    val isEmbedded: Boolean = false, // true for eSIM, false for physical SIM
    // LTE/5G cell details
    val ci: Int = 0, // Cell Identity
    val enb: Int = 0, // eNodeB ID
    val tac: Int = 0, // Tracking Area Code
    val pci: Int = 0, // Physical Cell ID
    val bandwidth: Int = 0, // Bandwidth in kHz
    val earfcn: Int = 0, // E-UTRA Absolute Radio Frequency Channel Number (LTE)
    val nrarfcn: Int = 0, // NR Absolute Radio Frequency Channel Number (5G)
    val rssi: Int = 0, // Received Signal Strength Indicator in dBm
    val rsrq: Int = 0, // Reference Signal Received Quality in dB
    val snr: Int = 0, // Signal-to-Noise Ratio in dB
    val cqi: Int = 0, // Channel Quality Indicator
    val timingAdvance: Int = 0 // Timing Advance
) {
    /**
     * Converts signal strength to a normalized value (0.0 to 1.0) for color mapping.
     * Typical RSRP range: -140 dBm (weak) to -50 dBm (strong)
     */
    fun getNormalizedStrength(): Float {
        val minStrength = -140f
        val maxStrength = -50f
        val normalized = (signalStrength - minStrength) / (maxStrength - minStrength)
        return normalized.coerceIn(0f, 1f)
    }

    /**
     * Converts to CSV format
     */
    fun toCsvRow(): String {
        return "${timestamp.toEpochMilli()},$latitude,$longitude,$altitude,$signalStrength,$cellId,$dataRateKbps,$networkType,$asu," +
                "$dataState,$dataActivity,$isRoaming,$simState,\"$simOperatorName\",$simMcc,$simMnc,\"$operatorName\",$mcc,$mnc,$phoneType," +
                "$simSlotIndex,$subscriptionId,\"$simDisplayName\",$isEmbedded," +
                "$ci,$enb,$tac,$pci,$bandwidth,$earfcn,$nrarfcn,$rssi,$rsrq,$snr,$cqi,$timingAdvance"
    }

    /**
     * Converts to GPX trackpoint format
     */
    fun toGpxTrackpoint(): String {
        return """
            <trkpt lat="$latitude" lon="$longitude">
                <ele>$altitude</ele>
                <time>${timestamp.toString()}</time>
                <extensions>
                    <signal:strength>$signalStrength</signal:strength>
                    <signal:cellId>$cellId</signal:cellId>
                    <signal:dataRate>$dataRateKbps</signal:dataRate>
                    <signal:networkType>$networkType</signal:networkType>
                    <signal:asu>$asu</signal:asu>
                    <signal:dataState>$dataState</signal:dataState>
                    <signal:dataActivity>$dataActivity</signal:dataActivity>
                    <signal:roaming>$isRoaming</signal:roaming>
                    <signal:simState>$simState</signal:simState>
                    <signal:simOperatorName>$simOperatorName</signal:simOperatorName>
                    <signal:simMcc>$simMcc</signal:simMcc>
                    <signal:simMnc>$simMnc</signal:simMnc>
                    <signal:operatorName>$operatorName</signal:operatorName>
                    <signal:mcc>$mcc</signal:mcc>
                    <signal:mnc>$mnc</signal:mnc>
                    <signal:phoneType>$phoneType</signal:phoneType>
                    <signal:simSlotIndex>$simSlotIndex</signal:simSlotIndex>
                    <signal:subscriptionId>$subscriptionId</signal:subscriptionId>
                    <signal:simDisplayName>$simDisplayName</signal:simDisplayName>
                    <signal:isEmbedded>$isEmbedded</signal:isEmbedded>
                    <signal:ci>$ci</signal:ci>
                    <signal:enb>$enb</signal:enb>
                    <signal:tac>$tac</signal:tac>
                    <signal:pci>$pci</signal:pci>
                    <signal:bandwidth>$bandwidth</signal:bandwidth>
                    <signal:earfcn>$earfcn</signal:earfcn>
                    <signal:nrarfcn>$nrarfcn</signal:nrarfcn>
                    <signal:rssi>$rssi</signal:rssi>
                    <signal:rsrq>$rsrq</signal:rsrq>
                    <signal:snr>$snr</signal:snr>
                    <signal:cqi>$cqi</signal:cqi>
                    <signal:timingAdvance>$timingAdvance</signal:timingAdvance>
                </extensions>
            </trkpt>
        """.trimIndent()
    }
}

================
File: app/src/main/java/com/signaldrivelogger/service/LoggingService.kt
================
package com.signaldrivelogger.service

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.location.Location
import android.os.Build
import android.os.IBinder
import androidx.core.app.NotificationCompat
import com.signaldrivelogger.R
import com.signaldrivelogger.data.FileLogger
import com.signaldrivelogger.data.LocationProvider
import com.signaldrivelogger.data.MultiSimMonitor
import com.signaldrivelogger.data.SignalRepository
import com.signaldrivelogger.data.SignalData
import com.signaldrivelogger.data.SimSignalData
import com.signaldrivelogger.data.TelephonyMonitor
import com.signaldrivelogger.ui.MainActivity
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch

/**
 * Foreground service that continuously logs signal and location data.
 */
class LoggingService : Service() {
    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)

    private lateinit var locationProvider: LocationProvider
    private lateinit var telephonyMonitor: TelephonyMonitor
    private lateinit var multiSimMonitor: MultiSimMonitor
    private lateinit var signalRepository: SignalRepository
    private lateinit var fileLogger: FileLogger

    private var currentLocation: Location? = null
    private val currentSignalDataBySim = mutableMapOf<Int, SignalData>() // Map of subscriptionId -> SignalData
    private var currentIntent: Intent? = null

    override fun onCreate() {
        super.onCreate()

        // Use shared instances from Application
        val app = application as com.signaldrivelogger.SignalDriveLoggerApplication
        locationProvider = app.locationProvider
        telephonyMonitor = app.telephonyMonitor
        multiSimMonitor = app.multiSimMonitor
        fileLogger = app.fileLogger
        signalRepository = app.signalRepository

        createNotificationChannel()
        startForeground(NOTIFICATION_ID, createNotification("Starting logging..."))
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        currentIntent = intent
        when (intent?.action) {
            ACTION_START_LOGGING -> startLogging()
            ACTION_STOP_LOGGING -> stopLogging()
        }
        return START_STICKY // Restart if killed
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun startLogging() {
        val filename = currentIntent?.getStringExtra(EXTRA_FILENAME) ?: "signal_log_${System.currentTimeMillis()}"
        signalRepository.setFilename(filename)
        signalRepository.startLogging(filename)

        // Start location updates
        locationProvider.getLocationUpdates()
            .onEach { location ->
                currentLocation = location
                updateNotification("Logging: ${location.latitude.format(6)}, ${location.longitude.format(6)}")
                // Records are created when signal data arrives for each SIM
            }
            .launchIn(serviceScope)

        // Start signal updates from all SIMs
        multiSimMonitor.getAllSimSignalUpdates()
            .onEach { simSignalData: SimSignalData ->
                currentSignalDataBySim[simSignalData.subscriptionId] = simSignalData.signalData
                val simCount = currentSignalDataBySim.size
                val signalData = simSignalData.signalData
                updateNotification("SIM ${simSignalData.subscriptionId}: ${signalData.signalStrength} dBm (${signalData.networkType}) - $simCount SIM(s)")
                tryCreateRecordForSim(simSignalData.subscriptionId, simSignalData.signalData)
            }
            .launchIn(serviceScope)
    }

    private fun stopLogging() {
        signalRepository.stopLogging()
        locationProvider.stopLocationUpdates()
        telephonyMonitor.stopMonitoring()
        currentSignalDataBySim.clear()

        // Finalize GPX file
        serviceScope.launch {
            fileLogger.finalizeGpx(signalRepository.getCurrentFilename())
        }

        updateNotification("Logging stopped")
        stopForeground(STOP_FOREGROUND_REMOVE)
        stopSelf()
    }

    private fun tryCreateRecordForSim(subscriptionId: Int, signalData: SignalData) {
        val location = currentLocation ?: return

        serviceScope.launch {
            val simSlotIndex = multiSimMonitor.getSimSlotIndex(subscriptionId)
            val simDisplayName = multiSimMonitor.getSimDisplayName(subscriptionId)
            val isEmbedded = multiSimMonitor.isEmbeddedSim(subscriptionId)

            val record = signalRepository.createRecord(
                location = location,
                signalData = signalData,
                dataRate = estimateDataRateForNetwork(signalData.networkType, signalData.signalStrength),
                simSlotIndex = simSlotIndex,
                subscriptionId = subscriptionId,
                simDisplayName = simDisplayName,
                isEmbedded = isEmbedded
            )

            record?.let {
                signalRepository.addRecord(it)
            }
        }
    }

    private fun estimateDataRateForNetwork(networkType: String, signalStrength: Int): Int {
        return when (networkType) {
            "5G" -> {
                when {
                    signalStrength > -70 -> 50000
                    signalStrength > -90 -> 30000
                    else -> 10000
                }
            }
            "LTE", "4G" -> {
                when {
                    signalStrength > -70 -> 20000
                    signalStrength > -90 -> 10000
                    else -> 5000
                }
            }
            "HSPA+", "HSPA" -> 5000
            "3G" -> 2000
            else -> 1000
        }
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Signal Logging Service",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Foreground service for logging signal strength"
            }
            val notificationManager = getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createNotification(text: String): Notification {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Cell Signal Logger")
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentIntent(pendingIntent)
            .setOngoing(true)
            .build()
    }

    private fun updateNotification(text: String) {
        val notification = createNotification(text)
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.notify(NOTIFICATION_ID, notification)
    }

    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
        locationProvider.stopLocationUpdates()
        telephonyMonitor.stopMonitoring()
    }

    companion object {
        const val ACTION_START_LOGGING = "com.signaldrivelogger.START_LOGGING"
        const val ACTION_STOP_LOGGING = "com.signaldrivelogger.STOP_LOGGING"
        const val EXTRA_FILENAME = "filename"
        private const val CHANNEL_ID = "logging_service_channel"
        private const val NOTIFICATION_ID = 1

        fun startLogging(context: Context, filename: String? = null) {
            val intent = Intent(context, LoggingService::class.java).apply {
                action = ACTION_START_LOGGING
                filename?.let { putExtra(EXTRA_FILENAME, it) }
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.startForegroundService(intent)
            } else {
                context.startService(intent)
            }
        }

        fun stopLogging(context: Context) {
            val intent = Intent(context, LoggingService::class.java).apply {
                action = ACTION_STOP_LOGGING
            }
            context.stopService(intent)
        }
    }
}

// Extension function to format doubles
private fun Double.format(decimals: Int): String = "%.${decimals}f".format(this)

================
File: app/src/main/java/com/signaldrivelogger/SignalDriveLoggerApplication.kt
================
package com.signaldrivelogger

import android.app.Application
import com.signaldrivelogger.data.FileLogger
import com.signaldrivelogger.data.LocationProvider
import com.signaldrivelogger.data.MultiSimMonitor
import com.signaldrivelogger.data.SignalRepository
import com.signaldrivelogger.data.TelephonyMonitor

class SignalDriveLoggerApplication : Application() {
    // Shared repository instance
    lateinit var signalRepository: SignalRepository
        private set

    lateinit var locationProvider: LocationProvider
        private set

    lateinit var telephonyMonitor: TelephonyMonitor
        private set

    lateinit var fileLogger: FileLogger
        private set

    lateinit var multiSimMonitor: MultiSimMonitor
        private set

    override fun onCreate() {
        super.onCreate()

        // Initialize shared instances
        locationProvider = LocationProvider(this)
        telephonyMonitor = TelephonyMonitor(this)
        fileLogger = FileLogger(this)
        multiSimMonitor = MultiSimMonitor(this)
        signalRepository = SignalRepository(locationProvider, telephonyMonitor, fileLogger)
    }
}

================
File: app/src/main/java/com/signaldrivelogger/ui/LoggingViewModel.kt
================
package com.signaldrivelogger.ui

import android.app.Application
import android.location.Location
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.signaldrivelogger.data.FileLogger
import com.signaldrivelogger.data.LocationProvider
import com.signaldrivelogger.data.SignalRepository
import com.signaldrivelogger.data.SignalData
import com.signaldrivelogger.data.TelephonyMonitor
import com.signaldrivelogger.data.MultiSimMonitor
import com.signaldrivelogger.domain.models.SignalRecord
import com.signaldrivelogger.service.LoggingService
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

/**
 * Data class representing a SIM card for UI display.
 */
data class SimInfo(
    val subscriptionId: Int,
    val displayName: String,
    val slotIndex: Int,
    val isEmbedded: Boolean
)

/**
 * ViewModel for managing logging state and UI data.
 */
class LoggingViewModel(application: Application) : AndroidViewModel(application) {
    // Use shared instances from Application
    private val app = application as com.signaldrivelogger.SignalDriveLoggerApplication
    private val locationProvider = app.locationProvider
    private val telephonyMonitor = app.telephonyMonitor
    private val fileLogger = app.fileLogger
    private val signalRepository = app.signalRepository
    private val multiSimMonitor = app.multiSimMonitor

    private val _isLogging = MutableStateFlow(false)
    val isLogging: StateFlow<Boolean> = _isLogging.asStateFlow()

    private val _records = MutableStateFlow<List<SignalRecord>>(emptyList())
    val records: StateFlow<List<SignalRecord>> = _records.asStateFlow()

    private val _currentLocation = MutableStateFlow<Location?>(null)
    val currentLocation: StateFlow<Location?> = _currentLocation.asStateFlow()

    // Track signal data for all SIMs by subscription ID
    private val _currentSignalDataBySim = MutableStateFlow<Map<Int, SignalData>>(emptyMap())
    val currentSignalDataBySim: StateFlow<Map<Int, SignalData>> = _currentSignalDataBySim.asStateFlow()

    // Legacy single SIM support (for backward compatibility)
    val currentSignalData: StateFlow<SignalData?> = _currentSignalDataBySim.asStateFlow().map {
        it.values.firstOrNull()
    }.stateIn(viewModelScope, SharingStarted.Lazily, null)

    private val _filename = MutableStateFlow("signal_log_${System.currentTimeMillis()}")
    val filename: StateFlow<String> = _filename.asStateFlow()

    // SIM selection for map filtering
    private val _availableSims = MutableStateFlow<List<SimInfo>>(emptyList())
    val availableSims: StateFlow<List<SimInfo>> = _availableSims.asStateFlow()

    private val _selectedSimIds = MutableStateFlow<Set<Int>>(emptySet())
    val selectedSimIds: StateFlow<Set<Int>> = _selectedSimIds.asStateFlow()

    init {
        // Observe records from repository
        viewModelScope.launch {
            signalRepository.records.collect { records ->
                _records.value = records
            }
        }

        // Observe signal data from all SIMs
        viewModelScope.launch {
            multiSimMonitor.getAllSimSignalUpdates().collect { simSignalData ->
                val currentMap = _currentSignalDataBySim.value.toMutableMap()
                currentMap[simSignalData.subscriptionId] = simSignalData.signalData
                _currentSignalDataBySim.value = currentMap
            }
        }
    }

    fun startLogging() {
        if (_isLogging.value) return

        _isLogging.value = true
        val filename = _filename.value
        LoggingService.startLogging(getApplication(), filename)
    }

    fun stopLogging() {
        if (!_isLogging.value) return

        _isLogging.value = false
        LoggingService.stopLogging(getApplication())
    }

    fun setFilename(filename: String) {
        _filename.value = filename
        signalRepository.setFilename(filename)
    }

    fun saveFile(format: String = "csv") {
        viewModelScope.launch {
            signalRepository.saveRecords(_filename.value, format)
        }
    }

    fun exportFile(): java.io.File? {
        return fileLogger.getFile(_filename.value, "csv")
    }

    fun clearRecords() {
        signalRepository.clearRecords()
    }

    fun hasLocationPermission(): Boolean {
        return locationProvider.hasPermission()
    }

    fun hasPhoneStatePermission(): Boolean {
        return telephonyMonitor.hasPermission()
    }

    private val _importError = MutableStateFlow<String?>(null)
    val importError: StateFlow<String?> = _importError.asStateFlow()

    private val _importSuccess = MutableStateFlow<String?>(null)
    val importSuccess: StateFlow<String?> = _importSuccess.asStateFlow()

    /**
     * Imports records from a CSV file.
     */
    suspend fun importCsvFile(inputStream: java.io.InputStream) {
        val result = signalRepository.importFromCsv(inputStream)
        result.fold(
            onSuccess = { message ->
                _importSuccess.value = message
            },
            onFailure = { error ->
                _importError.value = error.message ?: "Unknown error importing CSV file"
            }
        )
    }

    fun clearImportError() {
        _importError.value = null
    }

    fun clearImportSuccess() {
        _importSuccess.value = null
    }

    /**
     * Loads available SIM cards from the device.
     */
    fun loadAvailableSims() {
        viewModelScope.launch {
            val subscriptionIds = multiSimMonitor.getActiveSubscriptionIds()
            val sims = subscriptionIds.map { subId ->
                SimInfo(
                    subscriptionId = subId,
                    displayName = multiSimMonitor.getSimDisplayName(subId),
                    slotIndex = multiSimMonitor.getSimSlotIndex(subId),
                    isEmbedded = multiSimMonitor.isEmbeddedSim(subId)
                )
            }
            _availableSims.value = sims

            // If no SIMs are selected yet, select all by default
            if (_selectedSimIds.value.isEmpty() && sims.isNotEmpty()) {
                _selectedSimIds.value = sims.map { it.subscriptionId }.toSet()
            }
        }
    }

    /**
     * Toggles selection of a SIM card.
     */
    fun toggleSimSelection(subscriptionId: Int) {
        val current = _selectedSimIds.value.toMutableSet()
        if (current.contains(subscriptionId)) {
            current.remove(subscriptionId)
        } else {
            current.add(subscriptionId)
        }
        _selectedSimIds.value = current
    }

    /**
     * Gets filtered records for selected SIMs.
     */
    fun getFilteredRecords(): List<SignalRecord> {
        val selectedIds = _selectedSimIds.value
        if (selectedIds.isEmpty()) {
            return _records.value // Show all if none selected
        }
        return _records.value.filter { it.subscriptionId in selectedIds }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/ui/MainActivity.kt
================
package com.signaldrivelogger.ui

import android.Manifest
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.rememberMultiplePermissionsState
import com.signaldrivelogger.ui.theme.SignalDriveLoggerTheme

class MainActivity : ComponentActivity() {
    private val viewModel: LoggingViewModel by viewModels()

    // File picker launcher
    private val filePickerLauncher = registerForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { handleFileImport(it) }
    }

    @OptIn(ExperimentalPermissionsApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Handle shared file intent
        handleIntent(intent)

        setContent {
            SignalDriveLoggerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    val permissions = rememberMultiplePermissionsState(
                        permissions = listOf(
                            Manifest.permission.ACCESS_FINE_LOCATION,
                            Manifest.permission.ACCESS_COARSE_LOCATION,
                            Manifest.permission.READ_PHONE_STATE
                        ) + if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                            listOf(Manifest.permission.POST_NOTIFICATIONS)
                        } else {
                            emptyList()
                        }
                    )

                    LaunchedEffect(Unit) {
                        if (!permissions.allPermissionsGranted) {
                            permissions.launchMultiplePermissionRequest()
                        }
                    }

                    if (permissions.allPermissionsGranted) {
                        AppNavigation(viewModel = viewModel, mainActivity = this@MainActivity)
                    } else {
                        PermissionRequestScreen(
                            onRequestPermissions = { permissions.launchMultiplePermissionRequest() }
                        )
                    }
                }
            }
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        handleIntent(intent)
    }

    private fun handleIntent(intent: Intent?) {
        when (intent?.action) {
            Intent.ACTION_SEND -> {
                // Try EXTRA_STREAM first (for file attachments)
                val uri = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
                    intent.getParcelableExtra(Intent.EXTRA_STREAM, Uri::class.java)
                } else {
                    @Suppress("DEPRECATION")
                    intent.getParcelableExtra<Uri>(Intent.EXTRA_STREAM)
                }
                uri?.let { handleFileImport(it) }

                // Also try EXTRA_TEXT for text-based sharing
                if (uri == null) {
                    val text = intent.getStringExtra(Intent.EXTRA_TEXT)
                    text?.let {
                        // If it's a file path or URI, try to handle it
                        if (it.startsWith("file://") || it.startsWith("content://")) {
                            try {
                                handleFileImport(android.net.Uri.parse(it))
                            } catch (e: Exception) {
                                // Ignore
                            }
                        }
                    }
                }
            }
            Intent.ACTION_VIEW -> {
                intent.data?.let { handleFileImport(it) }
            }
        }
    }

    private fun handleFileImport(uri: Uri) {
        try {
            val inputStream = contentResolver.openInputStream(uri)
            inputStream?.let {
                CoroutineScope(Dispatchers.Main).launch {
                    viewModel.importCsvFile(it)
                }
            }
        } catch (e: Exception) {
            // Error will be handled by ViewModel
        }
    }

    fun launchFilePicker() {
        filePickerLauncher.launch("text/csv")
    }
}

@Composable
fun AppNavigation(viewModel: LoggingViewModel, mainActivity: MainActivity) {
    val navController = rememberNavController()

    NavHost(
        navController = navController,
        startDestination = "main"
    ) {
        composable("main") {
            MainScreen(
                viewModel = viewModel,
                onNavigateToMap = { navController.navigate("map") },
                onImportFile = { mainActivity.launchFilePicker() }
            )
        }
        composable("map") {
            MapScreen(viewModel = viewModel)
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PermissionRequestScreen(onRequestPermissions: () -> Unit) {
    CenterAlignedTopAppBar(
        title = { Text("Permissions Required") }
    )
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = "This app needs location and phone state permissions to log signal data.",
            style = MaterialTheme.typography.bodyLarge
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = onRequestPermissions) {
            Text("Grant Permissions")
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/ui/MainScreen.kt
================
package com.signaldrivelogger.ui

import android.content.Intent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import kotlinx.coroutines.launch
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import com.signaldrivelogger.data.SignalData

/**
 * Main screen with controls and signal information display.
 */
@Composable
fun MainScreen(
    viewModel: LoggingViewModel,
    onNavigateToMap: () -> Unit,
    onImportFile: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    val isLogging by viewModel.isLogging.collectAsState()
    val records by viewModel.records.collectAsState()
    val currentSignalDataBySim by viewModel.currentSignalDataBySim.collectAsState()
    val filename by viewModel.filename.collectAsState()

    var filenameInput by remember { mutableStateOf(filename) }
    val importError by viewModel.importError.collectAsState()
    val importSuccess by viewModel.importSuccess.collectAsState()
    val context = LocalContext.current
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Handle import error
    LaunchedEffect(importError) {
        importError?.let { error ->
            scope.launch {
                snackbarHostState.showSnackbar("Import Error: $error")
            }
            viewModel.clearImportError()
        }
    }

    // Handle import success
    LaunchedEffect(importSuccess) {
        importSuccess?.let { success ->
            scope.launch {
                snackbarHostState.showSnackbar(success)
            }
            viewModel.clearImportSuccess()
        }
    }

    Scaffold(
        modifier = modifier,
        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Title
            Text(
                text = "Cell Signal Logger",
                style = MaterialTheme.typography.headlineMedium
            )

            // Current Signal Info Card
            SignalInfoCard(signalDataBySim = currentSignalDataBySim)

            // Filename Input
            OutlinedTextField(
                value = filenameInput,
                onValueChange = { filenameInput = it },
                label = { Text("Log Filename") },
                modifier = Modifier.fillMaxWidth(),
                enabled = !isLogging,
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text)
            )

            // Control Buttons
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = {
                        viewModel.setFilename(filenameInput)
                        if (isLogging) {
                            viewModel.stopLogging()
                        } else {
                            viewModel.startLogging()
                        }
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text(if (isLogging) "Stop Logging" else "Start Logging")
                }

                Button(
                    onClick = onNavigateToMap,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("View Map")
                }
            }

            // Import Button
            Button(
                onClick = { onImportFile() },
                modifier = Modifier.fillMaxWidth(),
                enabled = !isLogging
            ) {
                Text("Import CSV File")
            }

            // File Actions
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = {
                        viewModel.setFilename(filenameInput)
                        viewModel.saveFile("csv")
                    },
                    modifier = Modifier.weight(1f),
                    enabled = records.isNotEmpty() && !isLogging
                ) {
                    Text("Save CSV")
                }

                Button(
                    onClick = {
                        viewModel.setFilename(filenameInput)
                        viewModel.saveFile("gpx")
                    },
                    modifier = Modifier.weight(1f),
                    enabled = records.isNotEmpty() && !isLogging
                ) {
                    Text("Save GPX")
                }
            }

            // Export/Share Button
            Button(
                onClick = {
                    val file = viewModel.exportFile()
                    file?.let {
                        val uri = androidx.core.content.FileProvider.getUriForFile(
                            context,
                            "${context.packageName}.fileprovider",
                            it
                        )
                        val shareIntent = Intent().apply {
                            action = Intent.ACTION_SEND
                            putExtra(Intent.EXTRA_STREAM, uri)
                            type = "text/csv"
                            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        }
                        context.startActivity(Intent.createChooser(shareIntent, "Share log file"))
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = records.isNotEmpty() && !isLogging
            ) {
                Text("Export/Share File")
            }

            // Stats Card
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Statistics",
                        style = MaterialTheme.typography.titleMedium
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text("Records: ${records.size}")
                    if (records.isNotEmpty()) {
                        val avgSignal = records.map { it.signalStrength }.average().toInt()
                        Text("Avg Signal: $avgSignal dBm")
                        val minSignal = records.minOfOrNull { it.signalStrength } ?: 0
                        val maxSignal = records.maxOfOrNull { it.signalStrength } ?: 0
                        Text("Signal Range: $minSignal to $maxSignal dBm")
                    }
                }
            }

            // Clear Button
            TextButton(
                onClick = { viewModel.clearRecords() },
                modifier = Modifier.fillMaxWidth(),
                enabled = records.isNotEmpty() && !isLogging
            ) {
                Text("Clear Records")
            }
        }

    }
}

/**
 * Card displaying current signal information for all SIMs.
 */
@Composable
private fun SignalInfoCard(signalDataBySim: Map<Int, SignalData>) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Current Signal",
                style = MaterialTheme.typography.titleMedium
            )
            Spacer(modifier = Modifier.height(8.dp))

            if (signalDataBySim.isNotEmpty()) {
                // Concatenate values from all SIMs
                val strengths = signalDataBySim.values.map { it.signalStrength }.joinToString("/")
                val networks = signalDataBySim.values.map { it.networkType }.joinToString("/")
                val cellIds = signalDataBySim.values.map { it.cellId }.joinToString("/")

                Text("Strength: $strengths dBm")
                Text("Network: $networks")
                Text("Cell ID: $cellIds")
            } else {
                Text("No signal data available")
            }
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt
================
package com.signaldrivelogger.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MyLocation
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import org.osmdroid.api.IMapController
import org.osmdroid.config.Configuration
import org.osmdroid.tileprovider.tilesource.TileSourceFactory
import org.osmdroid.util.GeoPoint
import org.osmdroid.views.MapView
import org.osmdroid.views.overlay.Polyline
import org.osmdroid.views.overlay.mylocation.GpsMyLocationProvider
import org.osmdroid.views.overlay.mylocation.MyLocationNewOverlay
import com.signaldrivelogger.domain.models.SignalRecord

/**
 * Map screen showing the route colored by signal strength using osmdroid.
 */
@Composable
fun MapScreen(
    viewModel: LoggingViewModel,
    modifier: Modifier = Modifier
) {
    val records by viewModel.records.collectAsState()
    val currentLocation by viewModel.currentLocation.collectAsState()
    val availableSims by viewModel.availableSims.collectAsState()
    val selectedSimIds by viewModel.selectedSimIds.collectAsState()
    val context = LocalContext.current

    // Load SIMs on first composition
    LaunchedEffect(Unit) {
        viewModel.loadAvailableSims()
    }

    // Get filtered records based on selected SIMs
    val filteredRecords = remember(records, selectedSimIds) {
        if (selectedSimIds.isEmpty()) {
            records // Show all if none selected
        } else {
            records.filter { it.subscriptionId in selectedSimIds }
        }
    }

    // Store map controller and location overlay references for centering
    val mapControllerRef = remember { mutableStateOf<IMapController?>(null) }
    val locationOverlayRef = remember { mutableStateOf<MyLocationNewOverlay?>(null) }

    // Initialize osmdroid configuration
    LaunchedEffect(Unit) {
        Configuration.getInstance().load(context, context.getSharedPreferences("osmdroid", android.content.Context.MODE_PRIVATE))
        Configuration.getInstance().userAgentValue = context.packageName
    }

    Box(modifier = modifier.fillMaxSize()) {
        AndroidView(
            factory = { ctx ->
                MapView(ctx).apply {
                    setTileSource(TileSourceFactory.MAPNIK)
                    setMultiTouchControls(true)
                    minZoomLevel = 3.0
                    maxZoomLevel = 21.0

                    // Set initial position
                    val initialRecords = if (selectedSimIds.isEmpty()) {
                        records
                    } else {
                        records.filter { it.subscriptionId in selectedSimIds }
                    }
                    val initialPoint = if (initialRecords.isNotEmpty()) {
                        GeoPoint(initialRecords.first().latitude, initialRecords.first().longitude)
                    } else if (currentLocation != null) {
                        GeoPoint(currentLocation!!.latitude, currentLocation!!.longitude)
                    } else {
                        GeoPoint(0.0, 0.0) // Default
                    }

                    val controller = controller
                    mapControllerRef.value = controller
                    controller.setZoom(15.0)
                    controller.setCenter(initialPoint)

                    // Add my location overlay
                    val locationOverlay = MyLocationNewOverlay(GpsMyLocationProvider(ctx), this)
                    locationOverlay.enableMyLocation()
                    locationOverlayRef.value = locationOverlay
                    overlays.add(locationOverlay)
                }
            },
            modifier = Modifier.fillMaxSize(),
            update = { mapView ->
                // Store controller reference
                mapControllerRef.value = mapView.controller

                // Update map when filtered records change
                updateMapWithRecords(mapView, filteredRecords)
            }
        )

        // Center on location button
        IconButton(
            onClick = {
                val controller = mapControllerRef.value
                if (controller != null) {
                    // Try to get location from ViewModel first
                    val location = currentLocation
                    if (location != null) {
                        val point = GeoPoint(location.latitude, location.longitude)
                        controller.animateTo(point)
                    } else {
                        // Fallback to location overlay's current location
                        val overlay = locationOverlayRef.value
                        overlay?.let {
                            val lastFix = it.lastFix
                            if (lastFix != null) {
                                val point = GeoPoint(lastFix.latitude, lastFix.longitude)
                                controller.animateTo(point)
                            } else {
                                // If no location available, center on first record or show message
                                if (filteredRecords.isNotEmpty()) {
                                    val firstRecord = filteredRecords.first()
                                    val point = GeoPoint(firstRecord.latitude, firstRecord.longitude)
                                    controller.animateTo(point)
                                }
                            }
                        }
                    }
                }
            },
            modifier = Modifier
                .align(Alignment.TopEnd)
                .padding(8.dp)
                .size(40.dp)
        ) {
            Icon(
                imageVector = Icons.Default.MyLocation,
                contentDescription = "Center on current location",
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(20.dp)
            )
        }

        // SIM selector buttons
        if (availableSims.isNotEmpty()) {
            SimSelectorButtons(
                sims = availableSims,
                selectedSimIds = selectedSimIds,
                onSimToggled = { subId -> viewModel.toggleSimSelection(subId) },
                modifier = Modifier
                    .align(Alignment.TopStart)
                    .padding(8.dp)
            )
        }

        // Color scale legend
        ColorScaleLegend(
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .padding(16.dp)
        )
    }
}

/**
 * Updates the map with signal strength colored polylines.
 */
private fun updateMapWithRecords(mapView: MapView, records: List<SignalRecord>) {
    // Remove existing polylines (except my location overlay)
    val overlaysToRemove = mapView.overlays.filter { it !is MyLocationNewOverlay }
    overlaysToRemove.forEach { mapView.overlays.remove(it) }

    if (records.size < 2) return

    // Create polylines colored by signal strength
    for (i in 0 until records.size - 1) {
        val record1 = records[i]
        val record2 = records[i + 1]

        val polyline = Polyline().apply {
            addPoint(GeoPoint(record1.latitude, record1.longitude))
            addPoint(GeoPoint(record2.latitude, record2.longitude))

            val color = getSignalColorAndroid(record1.signalStrength)
            paint.color = color
            width = 12f
        }

        mapView.overlays.add(polyline)
    }

    mapView.invalidate()
}

/**
 * Gets Android Color based on signal strength (green = strong, red = weak).
 */
private fun getSignalColorAndroid(signalStrength: Int): Int {
    // RSRP range: -140 dBm (weak) to -50 dBm (strong)
    val normalized = ((signalStrength + 140) / 90f).coerceIn(0f, 1f)

    return when {
        normalized > 0.75f -> android.graphics.Color.rgb(76, 175, 80)   // Green (strong)
        normalized > 0.5f -> android.graphics.Color.rgb(139, 195, 74)   // Light green
        normalized > 0.25f -> android.graphics.Color.rgb(255, 193, 7)   // Yellow
        else -> android.graphics.Color.rgb(244, 67, 54)                 // Red (weak)
    }
}

/**
 * Gets Compose Color based on signal strength (for legend).
 */
private fun getSignalColor(signalStrength: Int): androidx.compose.ui.graphics.Color {
    // RSRP range: -140 dBm (weak) to -50 dBm (strong)
    val normalized = ((signalStrength + 140) / 90f).coerceIn(0f, 1f)

    return when {
        normalized > 0.75f -> androidx.compose.ui.graphics.Color(0xFF4CAF50) // Green (strong)
        normalized > 0.5f -> androidx.compose.ui.graphics.Color(0xFF8BC34A) // Light green
        normalized > 0.25f -> androidx.compose.ui.graphics.Color(0xFFFFC107) // Yellow
        else -> androidx.compose.ui.graphics.Color(0xFFF44336) // Red (weak)
    }
}

/**
 * SIM selector buttons for filtering map display.
 */
@Composable
private fun SimSelectorButtons(
    sims: List<SimInfo>,
    selectedSimIds: Set<Int>,
    onSimToggled: (Int) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)
        )
    ) {
        Row(
            modifier = Modifier.padding(4.dp),
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            sims.forEachIndexed { index, sim ->
                val isSelected = sim.subscriptionId in selectedSimIds
                IconButton(
                    onClick = { onSimToggled(sim.subscriptionId) },
                    modifier = Modifier.size(36.dp)
                ) {
                    Box(
                        modifier = Modifier
                            .size(28.dp)
                            .background(
                                color = if (isSelected) {
                                    MaterialTheme.colorScheme.primary
                                } else {
                                    MaterialTheme.colorScheme.surfaceVariant
                                },
                                shape = androidx.compose.foundation.shape.CircleShape
                            ),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "${sim.slotIndex + 1}",
                            style = MaterialTheme.typography.labelSmall.copy(
                                fontSize = 12.sp,
                                color = if (isSelected) {
                                    MaterialTheme.colorScheme.onPrimary
                                } else {
                                    MaterialTheme.colorScheme.onSurfaceVariant
                                }
                            )
                        )
                    }
                }
            }
        }
    }
}

/**
 * Color scale legend showing signal strength gradient.
 */
@Composable
private fun ColorScaleLegend(modifier: Modifier = Modifier) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)
        )
    ) {
        Column(
            modifier = Modifier.padding(12.dp)
        ) {
            Text(
                text = "Signal Strength",
                style = MaterialTheme.typography.labelSmall
            )
            Spacer(modifier = Modifier.padding(vertical = 4.dp))

            // Gradient bar
            Box(
                modifier = Modifier
                    .height(20.dp)
                    .fillMaxWidth()
                    .background(
                        brush = Brush.horizontalGradient(
                            colors = listOf(
                                androidx.compose.ui.graphics.Color(0xFF4CAF50), // Green
                                androidx.compose.ui.graphics.Color(0xFF8BC34A), // Light green
                                androidx.compose.ui.graphics.Color(0xFFFFC107), // Yellow
                                androidx.compose.ui.graphics.Color(0xFFF44336)  // Red
                            )
                        )
                    )
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "-50 dBm",
                    style = MaterialTheme.typography.labelSmall.copy(fontSize = 10.sp)
                )
                Text(
                    text = "-140 dBm",
                    style = MaterialTheme.typography.labelSmall.copy(fontSize = 10.sp)
                )
            }
        }
    }
}

================
File: app/src/main/java/com/signaldrivelogger/ui/theme/Color.kt
================
package com.signaldrivelogger.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

================
File: app/src/main/java/com/signaldrivelogger/ui/theme/Theme.kt
================
package com.signaldrivelogger.ui.theme

import android.app.Activity
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40
)

@Composable
fun SignalDriveLoggerTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

================
File: app/src/main/java/com/signaldrivelogger/ui/theme/Type.kt
================
package com.signaldrivelogger.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
)

================
File: app/src/main/res/drawable/ic_launcher_foreground.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <group
        android:scaleX="0.8"
        android:scaleY="0.8"
        android:translateX="10.8"
        android:translateY="10.8">
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M54,27C40.2,27 29,38.2 29,52C29,65.8 40.2,77 54,77C67.8,77 79,65.8 79,52C79,38.2 67.8,27 54,27ZM54,70C44.1,70 36,61.9 36,52C36,42.1 44.1,34 54,34C63.9,34 72,42.1 72,52C72,61.9 63.9,70 54,70Z"/>
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M54,40C50.7,40 48,42.7 48,46V58C48,61.3 50.7,64 54,64C57.3,64 60,61.3 60,58V46C60,42.7 57.3,40 54,40Z"/>
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M54,36C52.3,36 51,37.3 51,39V45C51,46.7 52.3,48 54,48C55.7,48 57,46.7 57,45V39C57,37.3 55.7,36 54,36Z"/>
    </group>
</vector>

================
File: app/src/main/res/drawable/ic_notification.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#FF000000"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
</vector>

================
File: app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>

================
File: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>

================
File: app/src/main/res/mipmap-hdpi/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M24,0C10.7,0 0,10.7 0,24C0,37.3 10.7,48 24,48C37.3,48 48,37.3 48,24C48,10.7 37.3,0 24,0Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-hdpi/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M0,0h48v48h-48z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-mdpi/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M24,0C10.7,0 0,10.7 0,24C0,37.3 10.7,48 24,48C37.3,48 48,37.3 48,24C48,10.7 37.3,0 24,0Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-mdpi/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M0,0h48v48h-48z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-xhdpi/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M24,0C10.7,0 0,10.7 0,24C0,37.3 10.7,48 24,48C37.3,48 48,37.3 48,24C48,10.7 37.3,0 24,0Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-xhdpi/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M0,0h48v48h-48z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-xxhdpi/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M24,0C10.7,0 0,10.7 0,24C0,37.3 10.7,48 24,48C37.3,48 48,37.3 48,24C48,10.7 37.3,0 24,0Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-xxhdpi/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M0,0h48v48h-48z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M24,0C10.7,0 0,10.7 0,24C0,37.3 10.7,48 24,48C37.3,48 48,37.3 48,24C48,10.7 37.3,0 24,0Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/mipmap-xxxhdpi/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#6200EE"
        android:pathData="M0,0h48v48h-48z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,12C16.3,12 10,18.3 10,26C10,33.7 16.3,40 24,40C31.7,40 38,33.7 38,26C38,18.3 31.7,12 24,12ZM24,35C20.1,35 17,31.9 17,28C17,24.1 20.1,21 24,21C27.9,21 31,24.1 31,28C31,31.9 27.9,35 24,35Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M24,18C22.3,18 21,19.3 21,21V25C21,26.7 22.3,28 24,28C25.7,28 27,26.7 27,25V21C27,19.3 25.7,18 24,18Z"/>
</vector>

================
File: app/src/main/res/values/colors.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Signal strength colors -->
    <color name="signal_strong">#4CAF50</color>
    <color name="signal_good">#8BC34A</color>
    <color name="signal_medium">#FFC107</color>
    <color name="signal_weak">#F44336</color>

    <!-- Launcher icon colors -->
    <color name="ic_launcher_background">#6200EE</color>
</resources>

================
File: app/src/main/res/values/strings.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Cell Signal Logger</string>
    <string name="start_logging">Start Logging</string>
    <string name="stop_logging">Stop Logging</string>
    <string name="view_map">View Map</string>
    <string name="save_file">Save File</string>
    <string name="export_file">Export/Share File</string>
    <string name="signal_strength">Signal Strength</string>
    <string name="network_type">Network Type</string>
    <string name="cell_id">Cell ID</string>
    <string name="current_signal">Current Signal</string>
    <string name="no_signal_data">No signal data available</string>
    <string name="permissions_required">Permissions Required</string>
    <string name="permissions_message">This app needs location and phone state permissions to log signal data.</string>
    <string name="grant_permissions">Grant Permissions</string>
    <string name="logging_service_channel">Signal Logging Service</string>
    <string name="logging_service_description">Foreground service for logging signal strength</string>
</resources>

================
File: app/src/main/res/values/themes.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.SignalDriveLogger" parent="android:Theme.Material.Light.NoActionBar" />
</resources>

================
File: app/src/main/res/xml/file_paths.xml
================
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-files-path name="signal_logs" path="signal_logs/" />
</paths>

================
File: app/src/test/java/com/signaldrivelogger/data/FileLoggerTest.kt
================
package com.signaldrivelogger.data

import com.signaldrivelogger.domain.models.SignalRecord
import org.junit.Test
import org.junit.Assert.*
import java.io.File
import java.time.Instant

/**
 * Unit tests for FileLogger.
 * Note: These are simplified tests. In a real scenario, you'd use a test context.
 */
class FileLoggerTest {

    @Test
    fun testSignalRecordToCsv() {
        val record = SignalRecord(
            timestamp = Instant.parse("2023-11-04T12:34:56Z"),
            latitude = 37.7749,
            longitude = -122.4194,
            signalStrength = -85,
            cellId = 12345,
            dataRateKbps = 20000,
            networkType = "LTE"
        )

        val csvRow = record.toCsvRow()
        assertTrue(csvRow.contains("-85"))
        assertTrue(csvRow.contains("37.7749"))
        assertTrue(csvRow.contains("-122.4194"))
        assertTrue(csvRow.contains("LTE"))
    }

    @Test
    fun testSignalRecordToGpx() {
        val record = SignalRecord(
            timestamp = Instant.parse("2023-11-04T12:34:56Z"),
            latitude = 37.7749,
            longitude = -122.4194,
            signalStrength = -85,
            cellId = 12345,
            dataRateKbps = 20000,
            networkType = "LTE"
        )

        val gpxTrackpoint = record.toGpxTrackpoint()
        assertTrue(gpxTrackpoint.contains("37.7749"))
        assertTrue(gpxTrackpoint.contains("-122.4194"))
        assertTrue(gpxTrackpoint.contains("-85"))
        assertTrue(gpxTrackpoint.contains("LTE"))
    }

    @Test
    fun testNormalizedStrength() {
        val strongSignal = SignalRecord(
            timestamp = Instant.now(),
            latitude = 0.0,
            longitude = 0.0,
            signalStrength = -50, // Strong signal
            cellId = 0,
            dataRateKbps = 0,
            networkType = "LTE"
        )

        val weakSignal = SignalRecord(
            timestamp = Instant.now(),
            latitude = 0.0,
            longitude = 0.0,
            signalStrength = -140, // Weak signal
            cellId = 0,
            dataRateKbps = 0,
            networkType = "LTE"
        )

        val strongNormalized = strongSignal.getNormalizedStrength()
        val weakNormalized = weakSignal.getNormalizedStrength()

        assertTrue(strongNormalized > weakNormalized)
        assertTrue(strongNormalized >= 0f && strongNormalized <= 1f)
        assertTrue(weakNormalized >= 0f && weakNormalized <= 1f)
    }
}

================
File: build-error.txt
================
To honour the JVM settings for this build a single-use Daemon process will be forked. For more on this, please refer to https://docs.gradle.org/8.2/userguide/gradle_daemon.html#sec:disabling_the_daemon in the Gradle documentation.
Daemon will be stopped at the end of the build 
Warning: SDK processing. This version only understands SDK XML versions up to 3 but an SDK XML file of version 4 was encountered. This can happen if you use versions of Android Studio and the command-line tools that were released at different times.
> Task :app:checkKotlinGradlePluginConfigurationErrors
> Task :app:preBuild UP-TO-DATE
> Task :app:preDebugBuild UP-TO-DATE
> Task :app:checkDebugAarMetadata UP-TO-DATE
> Task :app:generateDebugResValues UP-TO-DATE
> Task :app:mapDebugSourceSetPaths UP-TO-DATE
> Task :app:generateDebugResources UP-TO-DATE
> Task :app:mergeDebugResources UP-TO-DATE
> Task :app:packageDebugResources UP-TO-DATE
> Task :app:parseDebugLocalResources UP-TO-DATE
> Task :app:createDebugCompatibleScreenManifests UP-TO-DATE
> Task :app:extractDeepLinksDebug UP-TO-DATE
> Task :app:processDebugMainManifest UP-TO-DATE
> Task :app:processDebugManifest UP-TO-DATE
> Task :app:processDebugManifestForPackage UP-TO-DATE
> Task :app:processDebugResources UP-TO-DATE

> Task :app:compileDebugKotlin FAILED
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:3:25 Conflicting import, imported name 'Color' is ambiguous
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:37:37 Conflicting import, imported name 'Color' is ambiguous
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:214:31 Function invocation 'Color(...)' expected
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:214:31 None of the following functions can be called with the arguments supplied: 
public fun Color(red: Float, green: Float, blue: Float, alpha: Float = ..., colorSpace: ColorSpace = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Int): Color defined in androidx.compose.ui.graphics
public fun Color(red: Int, green: Int, blue: Int, alpha: Int = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Long): Color defined in androidx.compose.ui.graphics
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:215:30 Function invocation 'Color(...)' expected
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:215:30 None of the following functions can be called with the arguments supplied: 
public fun Color(red: Float, green: Float, blue: Float, alpha: Float = ..., colorSpace: ColorSpace = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Int): Color defined in androidx.compose.ui.graphics
public fun Color(red: Int, green: Int, blue: Int, alpha: Int = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Long): Color defined in androidx.compose.ui.graphics
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:216:31 Function invocation 'Color(...)' expected
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:216:31 None of the following functions can be called with the arguments supplied: 
public fun Color(red: Float, green: Float, blue: Float, alpha: Float = ..., colorSpace: ColorSpace = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Int): Color defined in androidx.compose.ui.graphics
public fun Color(red: Int, green: Int, blue: Int, alpha: Int = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Long): Color defined in androidx.compose.ui.graphics
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:217:17 Function invocation 'Color(...)' expected
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MapScreen.kt:217:17 None of the following functions can be called with the arguments supplied: 
public fun Color(red: Float, green: Float, blue: Float, alpha: Float = ..., colorSpace: ColorSpace = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Int): Color defined in androidx.compose.ui.graphics
public fun Color(red: Int, green: Int, blue: Int, alpha: Int = ...): Color defined in androidx.compose.ui.graphics
public fun Color(color: Long): Color defined in androidx.compose.ui.graphics

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:compileDebugKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

* Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:compileDebugKotlin'.
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$1(ExecuteActionsTaskExecuter.java:149)
	at org.gradle.internal.Try$Failure.ifSuccessfulOrElse(Try.java:282)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:147)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)
	at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)
	at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)
	at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)
	at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)
	at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)
	at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:47)
Caused by: org.gradle.workers.internal.DefaultWorkerExecutor$WorkExecutionException: A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
	at org.gradle.workers.internal.DefaultWorkerExecutor$WorkItemExecution.waitForCompletion(DefaultWorkerExecutor.java:283)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.lambda$waitForItemsAndGatherFailures$2(DefaultAsyncWorkTracker.java:130)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLocks(DefaultWorkerLeaseService.java:321)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLocks(DefaultWorkerLeaseService.java:304)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLock(DefaultWorkerLeaseService.java:309)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForItemsAndGatherFailures(DefaultAsyncWorkTracker.java:126)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForItemsAndGatherFailures(DefaultAsyncWorkTracker.java:92)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForAll(DefaultAsyncWorkTracker.java:78)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForCompletion(DefaultAsyncWorkTracker.java:66)
	at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:256)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:68)
	at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:233)
	at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:216)
	at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:199)
	at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:166)
	at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)
	at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)
	at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)
	at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)
	at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)
	at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)
	at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)
	at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)
	at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)
	at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)
	at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)
	at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:50)
	at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:28)
	at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.executeDelegateBroadcastingChanges(CaptureStateAfterExecutionStep.java:100)
	at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:72)
	at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:50)
	at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)
	at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)
	at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:179)
	at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:70)
	at org.gradle.internal.Either$Right.fold(Either.java:175)
	at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:59)
	at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:68)
	at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:46)
	at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:36)
	at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:25)
	at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)
	at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:91)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:55)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:37)
	at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)
	at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)
	at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)
	at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)
	at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:77)
	at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:38)
	at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:94)
	at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:49)
	at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:71)
	at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:45)
	at org.gradle.internal.execution.steps.SkipEmptyWorkStep.executeWithNonEmptySources(SkipEmptyWorkStep.java:177)
	at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:86)
	at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:53)
	at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:32)
	at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:21)
	at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)
	at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)
	at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)
	at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:75)
	at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:41)
	at org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:32)
	at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:293)
	at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)
	at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:21)
	at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)
	at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)
	at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:47)
	at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:34)
	at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:64)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:146)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)
	at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)
	at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)
	at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)
	at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)
	at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)
	at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:47)
Caused by: org.jetbrains.kotlin.gradle.tasks.CompilationErrorException: Compilation error. See log for more details
	at org.jetbrains.kotlin.gradle.tasks.TasksUtilsKt.throwExceptionIfCompilationFailed(tasksUtils.kt:20)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:141)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:73)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:170)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:187)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:120)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:162)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:249)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:109)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:114)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:157)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:126)
	... 2 more


BUILD FAILED in 26s
14 actionable tasks: 2 executed, 12 up-to-date

================
File: build-errors.txt
================
To honour the JVM settings for this build a single-use Daemon process will be forked. For more on this, please refer to https://docs.gradle.org/8.2/userguide/gradle_daemon.html#sec:disabling_the_daemon in the Gradle documentation.
Daemon will be stopped at the end of the build 
Warning: SDK processing. This version only understands SDK XML versions up to 3 but an SDK XML file of version 4 was encountered. This can happen if you use versions of Android Studio and the command-line tools that were released at different times.
> Task :app:checkKotlinGradlePluginConfigurationErrors
> Task :app:preBuild UP-TO-DATE
> Task :app:preDebugBuild UP-TO-DATE
> Task :app:checkDebugAarMetadata UP-TO-DATE
> Task :app:generateDebugResValues UP-TO-DATE
> Task :app:mapDebugSourceSetPaths UP-TO-DATE
> Task :app:generateDebugResources UP-TO-DATE
> Task :app:mergeDebugResources UP-TO-DATE
> Task :app:packageDebugResources UP-TO-DATE
> Task :app:parseDebugLocalResources UP-TO-DATE
> Task :app:createDebugCompatibleScreenManifests UP-TO-DATE
> Task :app:extractDeepLinksDebug UP-TO-DATE
> Task :app:processDebugMainManifest UP-TO-DATE
> Task :app:processDebugManifest UP-TO-DATE
> Task :app:processDebugManifestForPackage UP-TO-DATE
> Task :app:processDebugResources UP-TO-DATE

> Task :app:compileDebugKotlin
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/SignalDriveLoggerApplication.kt:23:35 Unresolved reference: MultiSimMonitor
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/SignalDriveLoggerApplication.kt:33:27 Unresolved reference: MultiSimMonitor
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:153:46 Unresolved reference: launch
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:154:56 Suspension functions can be called only within coroutine body
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:170:46 Unresolved reference: launch
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:171:56 Suspension functions can be called only within coroutine body
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:188:37 Unresolved reference: defaultSubscriptionId
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:231:37 Unresolved reference: PhoneStateListener
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:271:39 Unresolved reference: PhoneStateListener
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:272:13 'onSignalStrengthsChanged' overrides nothing
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:276:53 Unresolved reference: PhoneStateListener
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:290:41 Unresolved reference: it
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:290:45 Unresolved reference: PhoneStateListener
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:297:38 Unresolved reference: it
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:297:42 Unresolved reference: PhoneStateListener
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/service/LoggingService.kt:37:43 Unresolved reference: MultiSimMonitor
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/service/LoggingService.kt:81:17 Unresolved reference: tryCreateRecord
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/service/LoggingService.kt:87:23 Cannot infer a type for this parameter. Please specify it explicitly.

> Task :app:compileDebugKotlin FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:compileDebugKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 24s
14 actionable tasks: 2 executed, 12 up-to-date

================
File: build.gradle.kts
================
// Top-level build file
plugins {
    id("com.android.application") version "8.7.2" apply false
    id("org.jetbrains.kotlin.android") version "1.9.24" apply false
}

================
File: compile-errors.txt
================
To honour the JVM settings for this build a single-use Daemon process will be forked. For more on this, please refer to https://docs.gradle.org/8.2/userguide/gradle_daemon.html#sec:disabling_the_daemon in the Gradle documentation.
Daemon will be stopped at the end of the build 
Warning: SDK processing. This version only understands SDK XML versions up to 3 but an SDK XML file of version 4 was encountered. This can happen if you use versions of Android Studio and the command-line tools that were released at different times.
> Task :app:checkKotlinGradlePluginConfigurationErrors
> Task :app:preBuild UP-TO-DATE
> Task :app:preDebugBuild UP-TO-DATE
> Task :app:checkDebugAarMetadata UP-TO-DATE
> Task :app:generateDebugResValues UP-TO-DATE
> Task :app:mapDebugSourceSetPaths UP-TO-DATE
> Task :app:generateDebugResources UP-TO-DATE
> Task :app:mergeDebugResources UP-TO-DATE
> Task :app:packageDebugResources UP-TO-DATE
> Task :app:parseDebugLocalResources UP-TO-DATE
> Task :app:createDebugCompatibleScreenManifests UP-TO-DATE
> Task :app:extractDeepLinksDebug UP-TO-DATE
> Task :app:processDebugMainManifest UP-TO-DATE
> Task :app:processDebugManifest UP-TO-DATE
> Task :app:processDebugManifestForPackage UP-TO-DATE
> Task :app:processDebugResources UP-TO-DATE

> Task :app:compileDebugKotlin
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MainScreen.kt:184:29 Unresolved reference: context
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MainScreen.kt:185:32 Unresolved reference: context
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/ui/MainScreen.kt:194:25 Unresolved reference: context

> Task :app:compileDebugKotlin FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:compileDebugKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 29s
14 actionable tasks: 2 executed, 12 up-to-date

================
File: create-keystore.ps1
================
# PowerShell script to create Android release keystore
# This will create a keystore file for signing your release APK/AAB

Write-Host "Android Release Keystore Generator" -ForegroundColor Cyan
Write-Host "===================================" -ForegroundColor Cyan
Write-Host ""

# Check if keytool is available
$keytoolPath = Get-Command keytool -ErrorAction SilentlyContinue
if (-not $keytoolPath) {
    Write-Host "Error: keytool not found in PATH." -ForegroundColor Red
    Write-Host "Please ensure Java JDK is installed and in your PATH." -ForegroundColor Yellow
    Write-Host ""
    Write-Host "You can find keytool at:" -ForegroundColor Yellow
    Write-Host "  C:\Program Files\Java\jdk-*\bin\keytool.exe" -ForegroundColor Gray
    Write-Host "  or" -ForegroundColor Gray
    Write-Host "  %JAVA_HOME%\bin\keytool.exe" -ForegroundColor Gray
    exit 1
}

# Default values
$keystoreName = "cell-signal-logger-release.jks"
$aliasName = "release"
$validityYears = 25  # Android requires at least 25 years for Play Store

Write-Host "This script will create a keystore for signing your release builds." -ForegroundColor Yellow
Write-Host ""
Write-Host "IMPORTANT:" -ForegroundColor Red
Write-Host "  - Keep your keystore file and passwords SECURE" -ForegroundColor Red
Write-Host "  - NEVER commit the keystore to git" -ForegroundColor Red
Write-Host "  - If you lose the keystore, you cannot update your app on Play Store" -ForegroundColor Red
Write-Host ""

# Check if keystore already exists
if (Test-Path $keystoreName) {
    Write-Host "Warning: $keystoreName already exists!" -ForegroundColor Yellow
    $overwrite = Read-Host "Do you want to overwrite it? (yes/no)"
    if ($overwrite -ne "yes") {
        Write-Host "Aborted." -ForegroundColor Yellow
        exit 0
    }
}

Write-Host "Keystore Configuration:" -ForegroundColor Cyan
Write-Host "  Keystore file: $keystoreName" -ForegroundColor Gray
Write-Host "  Key alias: $aliasName" -ForegroundColor Gray
Write-Host "  Validity: $validityYears years" -ForegroundColor Gray
Write-Host ""

# Get passwords
$keystorePassword = Read-Host "Enter keystore password" -AsSecureString
$keystorePasswordPlain = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
    [Runtime.InteropServices.Marshal]::SecureStringToBSTR($keystorePassword)
)

$keyPassword = Read-Host "Enter key password (or press Enter to use same as keystore)" -AsSecureString
$keyPasswordPlain = if ($keyPassword.Length -eq 0) {
    $keystorePasswordPlain
} else {
    [Runtime.InteropServices.Marshal]::PtrToStringAuto(
        [Runtime.InteropServices.Marshal]::SecureStringToBSTR($keyPassword)
    )
}

Write-Host ""
Write-Host "Enter certificate information:" -ForegroundColor Cyan
$firstName = Read-Host "First and Last Name (e.g., Your Name or Company Name)"
$organizationalUnit = Read-Host "Organizational Unit (e.g., Development)"
$organization = Read-Host "Organization (e.g., Your Company)"
$city = Read-Host "City or Locality"
$state = Read-Host "State or Province"
$countryCode = Read-Host "Two-letter Country Code (e.g., US, GB)"

Write-Host ""
Write-Host "Creating keystore..." -ForegroundColor Cyan

# Create the keystore
$dname = "CN=$firstName, OU=$organizationalUnit, O=$organization, L=$city, ST=$state, C=$countryCode"

try {
    $keytoolArgs = @(
        "-genkey",
        "-v",
        "-keystore", $keystoreName,
        "-alias", $aliasName,
        "-keyalg", "RSA",
        "-keysize", "2048",
        "-validity", ($validityYears * 365),
        "-storetype", "JKS",
        "-dname", $dname,
        "-storepass", $keystorePasswordPlain,
        "-keypass", $keyPasswordPlain
    )

    & keytool $keytoolArgs

    if ($LASTEXITCODE -eq 0) {
        Write-Host ""
        Write-Host "✓ Keystore created successfully!" -ForegroundColor Green
        Write-Host ""
        Write-Host "Keystore Details:" -ForegroundColor Cyan
        Write-Host "  File: $keystoreName" -ForegroundColor Gray
        Write-Host "  Alias: $aliasName" -ForegroundColor Gray
        Write-Host "  Location: $(Resolve-Path $keystoreName)" -ForegroundColor Gray
        Write-Host ""
        Write-Host "NEXT STEPS:" -ForegroundColor Yellow
        Write-Host "1. Store your passwords securely (password manager recommended)" -ForegroundColor Yellow
        Write-Host "2. Backup the keystore file to a secure location" -ForegroundColor Yellow
        Write-Host "3. Update app/build.gradle.kts with keystore configuration" -ForegroundColor Yellow
        Write-Host "4. The keystore is already in .gitignore - DO NOT commit it!" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "To verify the keystore, run:" -ForegroundColor Cyan
        Write-Host "  keytool -list -v -keystore $keystoreName" -ForegroundColor Gray
    } else {
        Write-Host "Error: Failed to create keystore" -ForegroundColor Red
        exit 1
    }
} catch {
    Write-Host "Error: $_" -ForegroundColor Red
    exit 1
} finally {
    # Clear passwords from memory
    $keystorePasswordPlain = $null
    $keyPasswordPlain = $null
}

================
File: gradle.properties
================
# Project-wide Gradle settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
android.useAndroidX=true
android.enableJetifier=true
kotlin.code.style=official

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: KEYSTORE_SETUP.md
================
# Keystore Setup Guide

This guide will help you create and configure a keystore for signing your Android release builds.

## Quick Start

1. **Run the keystore creation script:**
   ```powershell
   .\create-keystore.ps1
   ```

2. **Follow the prompts:**
   - Enter a strong keystore password (save it securely!)
   - Enter key password (or use same as keystore)
   - Enter certificate information (name, organization, etc.)

3. **Create keystore.properties file:**
   ```powershell
   Copy-Item keystore.properties.example keystore.properties
   ```
   Then edit `keystore.properties` and fill in your actual passwords.

4. **Build release APK:**
   ```powershell
   .\gradlew.bat assembleRelease
   ```

## Manual Keystore Creation

If you prefer to create the keystore manually:

```powershell
keytool -genkey -v -keystore cell-signal-logger-release.jks -alias release -keyalg RSA -keysize 2048 -validity 9125 -storetype JKS
```

**Parameters:**
- `-keystore`: Keystore filename
- `-alias`: Key alias name
- `-keyalg`: RSA algorithm
- `-keysize`: 2048 bits (recommended)
- `-validity`: 9125 days (25 years - required for Play Store)
- `-storetype`: JKS format

## Keystore Properties File

The `keystore.properties` file should contain:

```properties
storeFile=cell-signal-logger-release.jks
storePassword=Terapieea24!
keyAlias=release
keyPassword=Terapieea24!
```

**IMPORTANT:**
- This file is in `.gitignore` - DO NOT commit it!
- Store passwords in a secure password manager
- Keep a backup of both the keystore file and passwords

## Verifying Your Keystore

To verify the keystore was created correctly:

```powershell
keytool -list -v -keystore cell-signal-logger-release.jks
```

You'll be prompted for the keystore password, then you'll see certificate details.

## Security Best Practices

1. **Backup your keystore:**
   - Store in multiple secure locations
   - Use encrypted storage
   - Consider cloud backup (encrypted)

2. **Store passwords securely:**
   - Use a password manager
   - Never store in plain text files
   - Share securely with team members if needed

3. **Never commit to git:**
   - Keystore files are in `.gitignore`
   - `keystore.properties` is in `.gitignore`
   - Double-check before committing

4. **If you lose the keystore:**
   - You CANNOT update your app on Play Store
   - You'll need to create a new app listing
   - This is why backups are critical!

## Building Release APK/AAB

### APK (for direct distribution):
```powershell
.\gradlew.bat assembleRelease
```
Output: `app/build/outputs/apk/release/app-release.apk`

### AAB (for Play Store - recommended):
```powershell
.\gradlew.bat bundleRelease
```
Output: `app/build/outputs/bundle/release/app-release.aab`

## Troubleshooting

### "keytool not found"
- Ensure Java JDK is installed
- Add Java bin directory to PATH
- Or use full path: `C:\Program Files\Java\jdk-*\bin\keytool.exe`

### "Keystore was tampered with, or password was incorrect"
- Double-check your password
- Ensure you're using the correct keystore file

### "Signing config not found"
- Ensure `keystore.properties` exists
- Check that all properties are filled in correctly
- Verify keystore file path is correct

## Play Store App Signing

Google Play offers "App signing by Google Play" which:
- Lets Google manage your app signing key
- Reduces risk of losing your key
- Still requires an upload key (which you create)

You can enable this in Play Console after uploading your first app.

## Next Steps

After creating your keystore:
1. ✅ Test release build: `.\gradlew.bat assembleRelease`
2. ✅ Install and test on device
3. ✅ Create privacy policy
4. ✅ Prepare Play Store listing
5. ✅ Upload to Play Console

================
File: keystore.properties.example
================
# Keystore Configuration
# Copy this file to keystore.properties and fill in your actual values
# DO NOT commit keystore.properties to git!

storeFile=cell-signal-logger-release.jks
storePassword=Terapieea24!
keyAlias=release
keyPassword=Terapieea24!

================
File: kotlin-errors.txt
================
To honour the JVM settings for this build a single-use Daemon process will be forked. For more on this, please refer to https://docs.gradle.org/8.2/userguide/gradle_daemon.html#sec:disabling_the_daemon in the Gradle documentation.
Daemon will be stopped at the end of the build 
Warning: SDK processing. This version only understands SDK XML versions up to 3 but an SDK XML file of version 4 was encountered. This can happen if you use versions of Android Studio and the command-line tools that were released at different times.
> Task :app:checkKotlinGradlePluginConfigurationErrors
> Task :app:preBuild UP-TO-DATE
> Task :app:preDebugBuild UP-TO-DATE
> Task :app:checkDebugAarMetadata UP-TO-DATE
> Task :app:generateDebugResValues UP-TO-DATE
> Task :app:mapDebugSourceSetPaths UP-TO-DATE
> Task :app:generateDebugResources UP-TO-DATE
> Task :app:mergeDebugResources UP-TO-DATE
> Task :app:packageDebugResources UP-TO-DATE
> Task :app:parseDebugLocalResources UP-TO-DATE
> Task :app:createDebugCompatibleScreenManifests UP-TO-DATE
> Task :app:extractDeepLinksDebug UP-TO-DATE
> Task :app:processDebugMainManifest UP-TO-DATE
> Task :app:processDebugManifest UP-TO-DATE
> Task :app:processDebugManifestForPackage UP-TO-DATE
> Task :app:processDebugResources UP-TO-DATE

> Task :app:compileDebugKotlin
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/data/MultiSimMonitor.kt:193:37 Unresolved reference: defaultSubscriptionId
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/service/LoggingService.kt:37:43 Unresolved reference: MultiSimMonitor
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/service/LoggingService.kt:81:17 Unresolved reference: tryCreateRecord
e: file:///C:/Coding/cellgps/app/src/main/java/com/signaldrivelogger/service/LoggingService.kt:87:23 Cannot infer a type for this parameter. Please specify it explicitly.

> Task :app:compileDebugKotlin FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:compileDebugKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 21s
14 actionable tasks: 2 executed, 12 up-to-date

================
File: PLAY_STORE_CHECKLIST.md
================
# Play Store Publication Checklist

## ✅ Already Complete

1. **App Configuration**
   - ✅ Version code: 1
   - ✅ Version name: "1.0"
   - ✅ Target SDK: 34 (Android 14)
   - ✅ Min SDK: 26 (Android 8.0)
   - ✅ App name: "Cell Signal Logger"
   - ✅ Application ID: com.signaldrivelogger
   - ✅ App icons: Launcher icons configured

2. **Technical Requirements**
   - ✅ ProGuard rules configured
   - ✅ Permissions properly declared
   - ✅ Foreground service properly configured
   - ✅ FileProvider configured for file sharing
   - ✅ Intent filters for CSV file sharing

## ❌ Required Before Publishing

### 1. **App Signing (CRITICAL)**
   - [ ] Create release keystore
   - [ ] Configure signing in `build.gradle.kts`
   - [ ] Store keystore securely (NEVER commit to git)
   - [ ] Consider enabling "App signing by Google Play" (recommended)

**Action Required:**
```kotlin
// Add to app/build.gradle.kts:
android {
    signingConfigs {
        create("release") {
            storeFile = file("path/to/your-keystore.jks")
            storePassword = "your-store-password"
            keyAlias = "your-key-alias"
            keyPassword = "your-key-password"
        }
    }
    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("release")
            isMinifyEnabled = true  // Enable for release
            isShrinkResources = true  // Enable resource shrinking
        }
    }
}
```

### 2. **Privacy Policy (REQUIRED)**
   - [ ] Create privacy policy document
   - [ ] Host it online (GitHub Pages, your website, etc.)
   - [ ] Add privacy policy URL to Play Console
   - [ ] Link in app (optional but recommended)

**Required Content:**
- What data is collected (location, signal strength, cell ID)
- How data is used (stored locally, not transmitted)
- Data storage (local device only)
- User rights (can delete data)

### 3. **Data Safety Form (REQUIRED)**
   - [ ] Complete Data Safety section in Play Console
   - [ ] Declare location data collection
   - [ ] Declare device/phone identifiers (cell ID)
   - [ ] State that data is stored locally only
   - [ ] State that data is not shared with third parties

### 4. **Store Listing Assets**
   - [ ] App icon (512x512 PNG) - ✅ Already have
   - [ ] Feature graphic (1024x500 PNG)
   - [ ] Screenshots (at least 2, up to 8):
     - Phone: 16:9 or 9:16, min 320px, max 3840px
     - Tablet (optional): 16:9 or 9:16
   - [ ] App description (4000 chars max)
   - [ ] Short description (80 chars max)
   - [ ] Promotional text (optional, 80 chars)

### 5. **Content Rating**
   - [ ] Complete content rating questionnaire
   - [ ] Answer questions about app content
   - [ ] Get rating certificate

### 6. **Release Build**
   - [ ] Test release build thoroughly
   - [ ] Enable ProGuard/R8 minification
   - [ ] Test on multiple devices
   - [ ] Verify all features work in release mode

### 7. **Testing**
   - [ ] Test on Android 8.0+ devices
   - [ ] Test location permissions flow
   - [ ] Test background service
   - [ ] Test CSV import/export
   - [ ] Test map display
   - [ ] Test multi-SIM functionality

## 📋 Recommended Improvements

### 1. **User Experience**
   - [ ] Add onboarding/tutorial for first-time users
   - [ ] Add help/about screen
   - [ ] Improve error messages
   - [ ] Add data export confirmation

### 2. **Performance**
   - [ ] Enable R8 code shrinking
   - [ ] Enable resource shrinking
   - [ ] Optimize map rendering for large datasets
   - [ ] Add loading indicators

### 3. **Accessibility**
   - [ ] Add content descriptions to all interactive elements
   - [ ] Test with TalkBack
   - [ ] Ensure sufficient color contrast

### 4. **Localization** (Optional)
   - [ ] Consider translating to other languages
   - [ ] Add string resources for all text

## 🚀 Publishing Steps

1. **Prepare Release Build**
   ```powershell
   .\gradlew.bat assembleRelease
   ```

2. **Create App in Play Console**
   - Go to Google Play Console
   - Create new app
   - Fill in app details

3. **Upload APK/AAB**
   - Upload release AAB (recommended) or APK
   - Complete store listing
   - Upload screenshots and graphics

4. **Complete Required Forms**
   - Data Safety form
   - Content rating
   - Privacy policy URL

5. **Test Track (Recommended)**
   - Create internal test track
   - Test with internal testers
   - Create closed/open beta (optional)

6. **Submit for Review**
   - Review all information
   - Submit for production release
   - Wait for review (typically 1-7 days)

## ⚠️ Important Notes

1. **Location Data**: This app collects precise location data. You MUST:
   - Declare this in Data Safety form
   - Provide privacy policy explaining usage
   - Ensure users understand what data is collected

2. **Background Location**: Foreground service with location requires:
   - Clear explanation to users
   - Persistent notification (already implemented)
   - Proper permission handling (already implemented)

3. **Phone State Permission**: READ_PHONE_STATE requires:
   - Explanation of why it's needed (signal strength monitoring)
   - Declaration in Data Safety form

4. **Keystore Security**:
   - NEVER commit keystore to git
   - Store keystore password securely
   - Consider using environment variables or secure storage
   - Enable "App signing by Google Play" to let Google manage signing

## 📝 Sample Privacy Policy Template

You'll need to create a privacy policy. Here's what to include:

```
# Privacy Policy for Cell Signal Logger

## Data Collection
This app collects the following data:
- GPS location (latitude, longitude, altitude)
- Mobile signal strength
- Cell tower ID
- Network type and connection information
- Device information (SIM card details)

## Data Usage
All data is stored locally on your device only. No data is transmitted to external servers or third parties.

## Data Storage
Data is stored in CSV/GPX files on your device at:
Android/data/com.signaldrivelogger/files/signal_logs/

## Data Deletion
You can delete all logged data at any time using the "Clear Records" button in the app.

## Permissions
- Location: Required to log GPS coordinates with signal measurements
- Phone State: Required to read signal strength and cell information
- Notifications: Required for background service notification

## Contact
[Your contact information]
```

## 🎯 Quick Start Checklist

Before publishing, ensure you have:
1. ✅ Release keystore created and configured
2. ✅ Privacy policy created and hosted online
3. ✅ Release build tested and working
4. ✅ Screenshots prepared (at least 2)
5. ✅ Feature graphic created
6. ✅ App description written
7. ✅ Data Safety form completed
8. ✅ Content rating obtained

================
File: PRIVACY_POLICY_SETUP.md
================
# Privacy Policy Setup Guide

## Play Store Requirement

Google Play Store **requires** a privacy policy for apps that use sensitive permissions, including:
- `READ_PHONE_STATE` (which your app uses)
- Location permissions
- Other sensitive device data

## Quick Setup

### Option 1: Use GitHub Pages (Free & Easy)

1. **Create a GitHub repository** (or use your existing one)
2. **Create a file** `privacy-policy.md` in the repository
3. **Copy the content** from `PRIVACY_POLICY.md` in this project
4. **Enable GitHub Pages:**
   - Go to repository Settings → Pages
   - Select source branch (usually `main`)
   - Save
5. **Your privacy policy URL will be:**
   ```
   https://[your-username].github.io/[repository-name]/privacy-policy.html
   ```
   Or if you put it in the root:
   ```
   https://[your-username].github.io/[repository-name]/PRIVACY_POLICY.md
   ```

### Option 2: Use Your Own Website

1. Host the privacy policy on your website
2. Make it publicly accessible
3. Use the direct URL in Play Console

### Option 3: Use a Privacy Policy Generator

- **Privacy Policy Generator:** https://www.privacypolicygenerator.info/
- **Termly:** https://termly.io/products/privacy-policy-generator/
- **FreePrivacyPolicy:** https://www.freeprivacypolicy.com/

## Steps to Add Privacy Policy to Play Store

1. **Go to Google Play Console**
2. **Select your app**
3. **Navigate to:** Policy → App content
4. **Find:** "Privacy Policy" section
5. **Enter your privacy policy URL**
6. **Save**

## Important Notes

### Before Publishing:

1. **Update the Privacy Policy:**
   - Replace `[Your email address]` with your actual contact email
   - Update GitHub link if different
   - Customize any sections as needed

2. **Make it Accessible:**
   - Must be publicly accessible (no login required)
   - Should be a direct link (not behind a paywall)
   - Must be in a language your users understand

3. **Keep it Updated:**
   - Update when you add new features
   - Update when you change data collection practices
   - Keep the "Last Updated" date current

### What Play Store Checks:

- ✅ URL is accessible
- ✅ Privacy policy mentions the permissions you use
- ✅ Explains what data is collected
- ✅ Explains how data is used
- ✅ Explains data storage and sharing practices

## Template Customization

The provided `PRIVACY_POLICY.md` template includes:

- ✅ Explanation of READ_PHONE_STATE permission
- ✅ Location data collection explanation
- ✅ Data storage (local only)
- ✅ No third-party sharing
- ✅ User rights and data deletion
- ✅ Contact information placeholder

**You need to:**
1. Replace `[Your email address]` with your actual email
2. Verify the GitHub link is correct
3. Review and customize as needed for your specific use case

## Verification

After adding your privacy policy URL to Play Console:

1. Play Store will verify the URL is accessible
2. Review may take a few hours
3. You'll see a checkmark when approved

## Troubleshooting

**"Privacy policy URL is not accessible"**
- Make sure the URL is publicly accessible
- Test the URL in an incognito/private browser window
- Ensure no login is required

**"Privacy policy doesn't mention required permissions"**
- Make sure your policy mentions READ_PHONE_STATE
- Make sure it explains location data collection
- Be specific about what data is collected

**"Privacy policy format not supported"**
- Use HTML, PDF, or plain text
- GitHub Pages serves Markdown as HTML automatically
- Avoid Word documents or other proprietary formats

## Example URLs

If using GitHub Pages with your existing repository:
```
https://lightsaber42.github.io/cellgps/PRIVACY_POLICY.html
```

Or create a dedicated `privacy-policy.md` file:
```
https://lightsaber42.github.io/cellgps/privacy-policy.html
```

## Next Steps

1. ✅ Customize `PRIVACY_POLICY.md` with your contact info
2. ✅ Host it online (GitHub Pages recommended)
3. ✅ Add URL to Play Console
4. ✅ Wait for verification
5. ✅ Resubmit your app

================
File: PRIVACY_POLICY.md
================
# Privacy Policy

_Last updated: 3-Dec-2025_

## Introduction

Cell Signal Logger ("we," "our," or "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, and safeguard your information when you use our Cell Signal Logger mobile application ("the App").

## Information We Collect

### Location Data

The App collects and stores the following location information locally on your device:

* GPS coordinates (latitude, longitude, altitude)
* Timestamp of each location reading
* Location data is collected only when you actively start logging

### Phone and Signal Data

The App collects and stores the following device and signal information locally on your device:

* Mobile signal strength (RSRP in dBm)
* Cell tower identification numbers
* Network type (4G, 5G, LTE, etc.)
* Data connection status and activity
* SIM card information (for multi-SIM devices)
* Network operator information

**Note:** The App requires the READ_PHONE_STATE permission to access signal strength and cell tower information. This permission is essential for the App's core functionality of logging signal quality.

### Storage and Security

* All data is stored locally on your device
* No data is transmitted to external servers
* Your data remains private and under your control
* Data is stored at: `Android/data/com.signaldrivelogger/files/signal_logs/`

## How We Use Your Information

* To log signal strength measurements at your location
* To display your route on a map with color-coded signal strength
* To export your signal logs in CSV or GPX format
* To provide real-time signal strength information

## Data Sharing and Disclosure

* We do not collect or share your personal data with third parties
* We do not transmit your location or signal data to any external servers
* Your data remains on your device unless you explicitly choose to export or share it
* Map tiles are loaded from OpenStreetMap servers (no personal data is sent)

## Permissions Explained

### Location Permissions (ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION)
* **Required for:** Recording GPS coordinates with each signal measurement
* **Used when:** You actively start logging signal data
* **Can be revoked:** You can manage location permissions in your device settings

### Phone State Permission (READ_PHONE_STATE)
* **Required for:** Reading mobile signal strength and cell tower information
* **Used when:** You actively start logging signal data
* **Why needed:** Essential for the App's core functionality of measuring and logging signal quality
* **Can be revoked:** You can manage this permission in your device settings (App functionality will be limited)

### Foreground Service Permission
* **Required for:** Running the logging service in the background
* **Used when:** You start logging signal data
* **Notification:** A persistent notification is shown while logging is active

## Data Retention and Deletion

* You can delete all logged data at any time using the "Clear Records" button in the App
* You can manually delete log files from your device's file system
* Data remains on your device until you delete it
* Uninstalling the App will remove all App data from your device

## Children's Privacy

* The App is designed for use by individuals of all ages
* We do not knowingly collect personal information from children under 13
* Parents or guardians should supervise children's use of the App

## Your Rights

You have the right to:

* Access your data (stored locally on your device)
* Delete your data through the App's settings or by deleting log files
* Control app permissions through your device settings
* Export your data in CSV or GPX format
* Uninstall the App at any time

## Third-Party Services

The App uses the following third-party services:

* **OpenStreetMap (via osmdroid):** For displaying maps. No personal data is sent to OpenStreetMap servers.
* **Google Play Services Location:** For GPS location services. Location data is processed locally and not transmitted.

## Changes to This Privacy Policy

We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy in the App and updating the "Last updated" date.

## Contact Us

If you have questions about this Privacy Policy, please contact us at:
Email: info@achievetherapy.com

## Consent

By using the App, you consent to this Privacy Policy.

================
File: privacy-policy-cell-signal-logger.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy Policy - Cell Signal Logger</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        h3 {
            color: #555;
            margin-top: 20px;
        }
        ul {
            margin: 10px 0;
        }
        .last-updated {
            font-style: italic;
            color: #666;
            margin-bottom: 20px;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Privacy Policy</h1>
    <p class="last-updated"><em>Last updated: 3-Dec-2025</em></p>

    <h2>Introduction</h2>
    <p>Cell Signal Logger ("we," "our," or "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, and safeguard your information when you use our Cell Signal Logger mobile application ("the App").</p>

    <h2>Information We Collect</h2>

    <h3>Location Data</h3>
    <p>The App collects and stores the following location information locally on your device:</p>
    <ul>
        <li>GPS coordinates (latitude, longitude, altitude)</li>
        <li>Timestamp of each location reading</li>
        <li>Location data is collected only when you actively start logging</li>
    </ul>

    <h3>Phone and Signal Data</h3>
    <p>The App collects and stores the following device and signal information locally on your device:</p>
    <ul>
        <li>Mobile signal strength (RSRP in dBm)</li>
        <li>Cell tower identification numbers</li>
        <li>Network type (4G, 5G, LTE, etc.)</li>
        <li>Data connection status and activity</li>
        <li>SIM card information (for multi-SIM devices)</li>
        <li>Network operator information</li>
    </ul>
    <p><strong>Note:</strong> The App requires the READ_PHONE_STATE permission to access signal strength and cell tower information. This permission is essential for the App's core functionality of logging signal quality.</p>

    <h3>Storage and Security</h3>
    <ul>
        <li>All data is stored locally on your device</li>
        <li>No data is transmitted to external servers</li>
        <li>Your data remains private and under your control</li>
        <li>Data is stored at: <code>Android/data/com.signaldrivelogger/files/signal_logs/</code></li>
    </ul>

    <h2>How We Use Your Information</h2>
    <ul>
        <li>To log signal strength measurements at your location</li>
        <li>To display your route on a map with color-coded signal strength</li>
        <li>To export your signal logs in CSV or GPX format</li>
        <li>To provide real-time signal strength information</li>
    </ul>

    <h2>Data Sharing and Disclosure</h2>
    <ul>
        <li>We do not collect or share your personal data with third parties</li>
        <li>We do not transmit your location or signal data to any external servers</li>
        <li>Your data remains on your device unless you explicitly choose to export or share it</li>
        <li>Map tiles are loaded from OpenStreetMap servers (no personal data is sent)</li>
    </ul>

    <h2>Permissions Explained</h2>

    <h3>Location Permissions (ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION)</h3>
    <ul>
        <li><strong>Required for:</strong> Recording GPS coordinates with each signal measurement</li>
        <li><strong>Used when:</strong> You actively start logging signal data</li>
        <li><strong>Can be revoked:</strong> You can manage location permissions in your device settings</li>
    </ul>

    <h3>Phone State Permission (READ_PHONE_STATE)</h3>
    <ul>
        <li><strong>Required for:</strong> Reading mobile signal strength and cell tower information</li>
        <li><strong>Used when:</strong> You actively start logging signal data</li>
        <li><strong>Why needed:</strong> Essential for the App's core functionality of measuring and logging signal quality</li>
        <li><strong>Can be revoked:</strong> You can manage this permission in your device settings (App functionality will be limited)</li>
    </ul>

    <h3>Foreground Service Permission</h3>
    <ul>
        <li><strong>Required for:</strong> Running the logging service in the background</li>
        <li><strong>Used when:</strong> You start logging signal data</li>
        <li><strong>Notification:</strong> A persistent notification is shown while logging is active</li>
    </ul>

    <h2>Data Retention and Deletion</h2>
    <ul>
        <li>You can delete all logged data at any time using the "Clear Records" button in the App</li>
        <li>You can manually delete log files from your device's file system</li>
        <li>Data remains on your device until you delete it</li>
        <li>Uninstalling the App will remove all App data from your device</li>
    </ul>

    <h2>Children's Privacy</h2>
    <ul>
        <li>The App is designed for use by individuals of all ages</li>
        <li>We do not knowingly collect personal information from children under 13</li>
        <li>Parents or guardians should supervise children's use of the App</li>
    </ul>

    <h2>Your Rights</h2>
    <p>You have the right to:</p>
    <ul>
        <li>Access your data (stored locally on your device)</li>
        <li>Delete your data through the App's settings or by deleting log files</li>
        <li>Control app permissions through your device settings</li>
        <li>Export your data in CSV or GPX format</li>
        <li>Uninstall the App at any time</li>
    </ul>

    <h2>Third-Party Services</h2>
    <p>The App uses the following third-party services:</p>
    <ul>
        <li><strong>OpenStreetMap (via osmdroid):</strong> For displaying maps. No personal data is sent to OpenStreetMap servers.</li>
        <li><strong>Google Play Services Location:</strong> For GPS location services. Location data is processed locally and not transmitted.</li>
    </ul>

    <h2>Changes to This Privacy Policy</h2>
    <p>We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy in the App and updating the "Last updated" date.</p>

    <h2>Contact Us</h2>
    <p>If you have questions about this Privacy Policy, please contact us at:<br>
    Email: <a href="mailto:info@achievetherapy.com">info@achievetherapy.com</a></p>

    <h2>Consent</h2>
    <p>By using the App, you consent to this Privacy Policy.</p>

    <p><a href="/">Back to Home</a></p>
</body>
</html>

================
File: PROJECT_STRUCTURE.md
================
# Project Structure

## Complete File List

```
Cell Signal Logger/
├── app/
│   ├── build.gradle.kts              # App-level Gradle configuration
│   ├── proguard-rules.pro            # ProGuard rules
│   └── src/
│       ├── main/
│       │   ├── AndroidManifest.xml   # App manifest with permissions
│       │   ├── java/com/signaldrivelogger/
│       │   │   ├── SignalDriveLoggerApplication.kt
│       │   │   ├── data/
│       │   │   │   ├── FileLogger.kt           # CSV/GPX file operations
│       │   │   │   ├── LocationProvider.kt     # GPS location provider
│       │   │   │   ├── SignalRepository.kt     # Combines location + signal
│       │   │   │   └── TelephonyMonitor.kt     # Signal strength monitoring
│       │   │   ├── domain/models/
│       │   │   │   └── SignalRecord.kt         # Data model
│       │   │   ├── service/
│       │   │   │   └── LoggingService.kt       # Foreground service
│       │   │   └── ui/
│       │   │       ├── LoggingViewModel.kt     # ViewModel
│       │   │       ├── MainActivity.kt         # Main activity
│       │   │       ├── MainScreen.kt           # Main UI screen
│       │   │       ├── MapScreen.kt            # Map display screen
│       │   │       └── theme/
│       │   │           ├── Color.kt
│       │   │           ├── Theme.kt
│       │   │           └── Type.kt
│       │   └── res/
│       │       ├── drawable/
│       │       │   └── ic_notification.xml
│       │       ├── values/
│       │       │   ├── colors.xml
│       │       │   ├── strings.xml
│       │       │   └── themes.xml
│       │       └── xml/
│       │           └── file_paths.xml          # FileProvider paths
│       └── test/java/com/signaldrivelogger/data/
│           └── FileLoggerTest.kt               # Unit tests
├── build.gradle.kts                  # Project-level Gradle
├── settings.gradle.kts               # Gradle settings
├── gradle.properties                # Gradle properties
├── .gitignore
├── README.md                         # Main documentation
├── SETUP.md                          # Setup instructions
└── PROJECT_STRUCTURE.md              # This file
```

## Key Components

### Data Layer
- **LocationProvider**: Handles GPS location updates using FusedLocationProviderClient
- **TelephonyMonitor**: Monitors signal strength, cell ID, and network type
- **SignalRepository**: Combines location and signal data into SignalRecord objects
- **FileLogger**: Handles CSV and GPX file operations

### Domain Layer
- **SignalRecord**: Core data model with location, signal strength, and metadata

### Service Layer
- **LoggingService**: Foreground service that runs in background, collects data, and logs to files

### UI Layer
- **MainScreen**: Controls for start/stop logging, save, export
- **MapScreen**: osmdroid (OpenStreetMap) display with color-coded route
- **LoggingViewModel**: Manages app state and coordinates data collection

## Data Flow

1. User taps "Start Logging"
2. MainActivity → ViewModel → LoggingService.startLogging()
3. LoggingService starts:
   - LocationProvider.getLocationUpdates() (Flow)
   - TelephonyMonitor.getSignalStrengthUpdates() (Flow)
4. When both location and signal data are available:
   - Create SignalRecord
   - Add to repository
   - Log to file (CSV + GPX)
5. UI observes repository.records Flow and updates map

## File Locations

- **Log files**: `Android/data/com.signaldrivelogger/files/signal_logs/`
- **CSV format**: `filename.csv`
- **GPX format**: `filename.gpx`

## Dependencies

Key dependencies (see `app/build.gradle.kts`):
- Jetpack Compose
- osmdroid (OpenStreetMap)
- Google Play Services Location
- Coroutines
- Navigation Compose
- Accompanist Permissions

================
File: README.md
================
# Cell Signal Logger

A production-ready Android app that logs mobile signal strength while driving, displays the route on a map colored by signal strength, and runs in the background.

## Features

- **Background Signal Logging**: Continuously logs signal strength, cell ID, network type, and data rate
- **GPS Location Tracking**: Captures location every 1-5 seconds
- **File Logging**: Exports data to CSV or GPX format
- **Interactive Map**: Displays route with color-coded signal strength (green = strong, red = weak)
- **Foreground Service**: Runs in background with persistent notification
- **Real-time Display**: Shows current signal strength and network type

## Setup

### 1. No API Key Required!

This app uses **osmdroid** with **OpenStreetMap** tiles, so no API key is needed. Just build and run!

### 2. Build the Project

**On Windows (PowerShell):**
```powershell
.\gradlew.bat build
```

**On Linux/Mac:**
```bash
./gradlew build
```

### 3. Install on Device

**On Windows (PowerShell):**
```powershell
.\gradlew.bat installDebug
```

**On Linux/Mac:**
```bash
./gradlew installDebug
```

## Permissions

The app requires the following permissions:
- `ACCESS_FINE_LOCATION` - For GPS tracking
- `ACCESS_COARSE_LOCATION` - For approximate location
- `READ_PHONE_STATE` - For signal strength monitoring
- `FOREGROUND_SERVICE` - For background logging
- `FOREGROUND_SERVICE_LOCATION` - For location-based foreground service
- `POST_NOTIFICATIONS` - For service notification (Android 13+)

## Usage

1. **Start Logging**: Tap "Start Logging" to begin recording signal data
2. **View Map**: Tap "View Map" to see your route colored by signal strength
3. **Save File**: Choose CSV or GPX format and save your log
4. **Export/Share**: Share the log file with other apps

## File Formats

### CSV Format
```
timestamp,latitude,longitude,signal_strength_dbm,cell_id,data_rate_kbps,network_type,asu
1699123456789,37.7749,-122.4194,-85,12345,20000,LTE,0
```

### GPX Format
Standard GPX with custom extensions for signal data:
```xml
<trkpt lat="37.7749" lon="-122.4194">
    <time>2023-11-04T12:34:56Z</time>
    <extensions>
        <signal:strength>-85</signal:strength>
        <signal:cellId>12345</signal:cellId>
        <signal:dataRate>20000</signal:dataRate>
        <signal:networkType>LTE</signal:networkType>
    </extensions>
</trkpt>
```

## Architecture

```
/app
  /data
    - SignalRepository.kt      # Combines location and signal data
    - FileLogger.kt            # Handles CSV/GPX file operations
    - LocationProvider.kt       # GPS location provider
    - TelephonyMonitor.kt      # Signal strength monitoring
  /domain
    /models
      - SignalRecord.kt        # Data model
  /ui
    - MainScreen.kt            # Main UI with controls
    - MapScreen.kt             # Map display with colored route
    - LoggingViewModel.kt      # ViewModel for state management
    - MainActivity.kt          # Main activity
  /service
    - LoggingService.kt        # Foreground service
```

## Technical Details

- **Min SDK**: 26 (Android 8.0)
- **Target SDK**: 34 (Android 14)
- **Language**: Kotlin
- **UI Framework**: Jetpack Compose
- **Maps**: osmdroid (OpenStreetMap)
- **Location**: FusedLocationProviderClient
- **Signal**: TelephonyManager with SignalStrengthCallback

## Testing

Run unit tests:
```bash
./gradlew test
```

Run instrumented tests:
```bash
./gradlew connectedAndroidTest
```

## Notes

- Signal strength is measured in dBm (RSRP for LTE/5G)
- Typical range: -140 dBm (weak) to -50 dBm (strong)
- Data rate is estimated based on network type and signal strength
- Files are saved to `Android/data/com.signaldrivelogger/files/signal_logs/`

## License

This project is provided as-is for educational and development purposes.

================
File: REPOMIX_USAGE.md
================
# Repomix Configuration Usage

This repository includes configuration files for [Repomix](https://github.com/toptal/repomix), a tool that exports your codebase while excluding unnecessary files.

## Configuration Files

- **`.repomixrc`** - JSON format configuration
- **`repomix.config.yaml`** - YAML format configuration (alternative)

Both configurations are set up to:
- ✅ Include all source code (Kotlin, XML, Gradle files)
- ✅ Include documentation (Markdown, HTML)
- ✅ Include scripts (PowerShell)
- ✅ Include configuration examples
- ❌ Exclude build artifacts (`build/`, `.gradle/`, etc.)
- ❌ Exclude sensitive files (keystores, `local.properties`)
- ❌ Exclude IDE files (`.idea/`, `*.iml`)
- ❌ Exclude screenshots and test data
- ❌ Exclude generated files and logs

## Installation

Install Repomix globally:
```bash
npm install -g repomix
```

Or use it directly with npx:
```bash
npx repomix
```

## Usage

### Using the JSON config (`.repomixrc`):
```bash
repomix --config .repomixrc
```

### Using the YAML config:
```bash
repomix --config repomix.config.yaml
```

### Without specifying config (uses `.repomixrc` by default):
```bash
repomix
```

## Output

The exported codebase will be saved to `./repomix-output/` directory by default.

## What Gets Exported

### Included:
- All Kotlin source files (`*.kt`)
- All Gradle build files (`*.gradle.kts`, `*.gradle`)
- Android resources (`*.xml` in `res/`)
- Documentation (`*.md`, `*.html`)
- PowerShell scripts (`*.ps1`)
- Configuration examples (`keystore.properties.example`)
- Gradle wrapper properties

### Excluded:
- Build artifacts (`app/build/`, `build/`)
- Gradle cache (`.gradle/`)
- IDE files (`.idea/`, `*.iml`)
- Sensitive files (keystores, `local.properties`)
- Screenshots and test CSV files
- Generated files and logs
- Binary files (APK, AAB, JAR, etc.)

## Customization

You can modify either configuration file to:
- Add more file patterns to include/exclude
- Change the output path
- Adjust ignore rules

For more information, see the [Repomix documentation](https://github.com/toptal/repomix).

================
File: settings.gradle.kts
================
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "SignalDriveLogger"
include(":app")

================
File: setup-android-env.ps1
================
# Android Studio Environment Setup Script for PowerShell
# Run this script to set up Android development environment in your current PowerShell session

Write-Host "Setting up Android Studio environment..." -ForegroundColor Green

# Set Android SDK path (default location)
$androidSdkPath = "$env:LOCALAPPDATA\Android\Sdk"

if (-not (Test-Path $androidSdkPath)) {
    Write-Host "Warning: Android SDK not found at: $androidSdkPath" -ForegroundColor Yellow
    Write-Host "Please install Android SDK or update the path in this script." -ForegroundColor Yellow
    exit 1
}

# Set environment variables for current session
$env:ANDROID_HOME = $androidSdkPath
$env:ANDROID_SDK_ROOT = $androidSdkPath

# Add Android SDK tools to PATH
$platformTools = "$androidSdkPath\platform-tools"
$tools = "$androidSdkPath\tools"
$toolsBin = "$androidSdkPath\tools\bin"

if (Test-Path $platformTools) {
    $env:PATH = "$platformTools;$env:PATH"
    Write-Host "Added platform-tools to PATH" -ForegroundColor Green
}

if (Test-Path $tools) {
    $env:PATH = "$tools;$env:PATH"
    Write-Host "Added tools to PATH" -ForegroundColor Green
}

if (Test-Path $toolsBin) {
    $env:PATH = "$toolsBin;$env:PATH"
    Write-Host "Added tools\bin to PATH" -ForegroundColor Green
}

# Create local.properties if it doesn't exist
$localPropertiesPath = "local.properties"
if (-not (Test-Path $localPropertiesPath)) {
    $sdkDir = $androidSdkPath -replace '\\', '\\'
    $content = @"
## This file must *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
sdk.dir=$sdkDir
"@
    $content | Out-File -FilePath $localPropertiesPath -Encoding UTF8
    Write-Host "Created local.properties file" -ForegroundColor Green
} else {
    Write-Host "local.properties already exists" -ForegroundColor Yellow
}

# Verify setup
Write-Host "`nEnvironment Setup Complete!" -ForegroundColor Green
Write-Host "ANDROID_HOME: $env:ANDROID_HOME" -ForegroundColor Cyan
Write-Host "ANDROID_SDK_ROOT: $env:ANDROID_SDK_ROOT" -ForegroundColor Cyan
Write-Host "`nYou can now run:" -ForegroundColor Yellow
Write-Host "  .\gradlew.bat build" -ForegroundColor White
Write-Host "  .\gradlew.bat installDebug" -ForegroundColor White

================
File: SETUP.md
================
# Setup Guide for Cell Signal Logger

## Prerequisites

1. **Android Studio** (Hedgehog or later recommended)
2. **JDK 17** or later
3. **Android SDK** with API 26+ and build tools
4. **No API key required!** This app uses osmdroid with OpenStreetMap

## Step 1: No Setup Required!

This app uses **osmdroid** with **OpenStreetMap** tiles, so no API key configuration is needed. The maps work out of the box!

## Step 2: Build and Run

### Using Android Studio:
1. Open the project in Android Studio
2. Wait for Gradle sync to complete
3. Connect an Android device or start an emulator
4. Click **Run** (green play button)

### Using Command Line:

**On Windows (PowerShell):**
```powershell
# Build the project
.\gradlew.bat build

# Install on connected device
.\gradlew.bat installDebug

# Run tests
.\gradlew.bat test
```

**On Linux/Mac:**
```bash
# Build the project
./gradlew build

# Install on connected device
./gradlew installDebug

# Run tests
./gradlew test
```

## Step 3: Grant Permissions

On first launch, the app will request:
- **Location** (Fine and Coarse)
- **Phone State** (for signal strength)
- **Notifications** (Android 13+)

Grant all permissions to use the app.

## Troubleshooting

### Maps Not Showing
- Ensure device has internet connection (needed to download map tiles)
- Check that INTERNET permission is granted
- osmdroid uses OpenStreetMap tiles which are free and don't require an API key

### No Signal Data
- Check that READ_PHONE_STATE permission is granted
- Verify device has cellular connection (not just WiFi)
- Some emulators may not provide signal data

### Location Not Working
- Ensure location permission is granted
- Check device location services are enabled
- Try testing outdoors for better GPS accuracy

### Build Errors
- Ensure you're using JDK 17+
- Sync Gradle files: **File** → **Sync Project with Gradle Files**
- Clean and rebuild: **Build** → **Clean Project**, then **Build** → **Rebuild Project**

## Testing on Emulator

For testing signal data on an emulator:
1. Use Android Studio's extended controls
2. Go to **Cellular** tab
3. Set signal strength and network type manually
4. Note: Real signal data requires a physical device

## Next Steps

- Review the code structure in `README.md`
- Customize update intervals in `LocationProvider.kt` and `TelephonyMonitor.kt`
- Adjust signal strength color mapping in `MapScreen.kt`
- Add additional export formats if needed

================
File: update-version.ps1
================
# PowerShell script to update app version for Play Store uploads
# Increments version code and optionally updates version name

param(
    [string]$VersionName = "",
    [switch]$BuildBundle = $false,
    [switch]$AutoIncrement = $true
)

$buildGradlePath = "app\build.gradle.kts"

if (-not (Test-Path $buildGradlePath)) {
    Write-Host "Error: build.gradle.kts not found at $buildGradlePath" -ForegroundColor Red
    exit 1
}

Write-Host "Updating app version for Play Store..." -ForegroundColor Cyan
Write-Host ""

# Read current build.gradle.kts
$content = Get-Content $buildGradlePath -Raw

# Extract current version code
if ($content -match 'versionCode\s*=\s*(\d+)') {
    $currentVersionCode = [int]$matches[1]
    Write-Host "Current version code: $currentVersionCode" -ForegroundColor Gray
} else {
    Write-Host "Error: Could not find versionCode in build.gradle.kts" -ForegroundColor Red
    exit 1
}

# Extract current version name
if ($content -match 'versionName\s*=\s*"([^"]+)"') {
    $currentVersionName = $matches[1]
    Write-Host "Current version name: $currentVersionName" -ForegroundColor Gray
} else {
    Write-Host "Error: Could not find versionName in build.gradle.kts" -ForegroundColor Red
    exit 1
}

# Calculate new version code
$newVersionCode = if ($AutoIncrement) {
    $currentVersionCode + 1
} else {
    $currentVersionCode
}

# Determine new version name
$newVersionName = if ($VersionName -ne "") {
    $VersionName
} else {
    # Auto-increment version name (e.g., "1.0" -> "1.1", "1.1" -> "1.2")
    if ($currentVersionName -match '^(\d+)\.(\d+)(?:\.(\d+))?$') {
        $major = [int]$matches[1]
        $minor = [int]$matches[2]
        $patch = if ($matches[3]) { [int]$matches[3] } else { 0 }

        # Increment patch version, or minor if patch is 9+
        if ($patch -lt 9) {
            $patch++
        } else {
            $minor++
            $patch = 0
        }

        "$major.$minor.$patch"
    } else {
        # If version format doesn't match, just increment patch
        "$currentVersionName.1"
    }
}

Write-Host ""
Write-Host "New version:" -ForegroundColor Cyan
Write-Host "  Version Code: $newVersionCode (was $currentVersionCode)" -ForegroundColor Green
Write-Host "  Version Name: $newVersionName (was $currentVersionName)" -ForegroundColor Green
Write-Host ""

# Confirm with user
$confirm = Read-Host "Update version? (Y/N)"
if ($confirm -ne "Y" -and $confirm -ne "y") {
    Write-Host "Cancelled." -ForegroundColor Yellow
    exit 0
}

# Update version code
$content = $content -replace "versionCode\s*=\s*\d+", "versionCode = $newVersionCode"

# Update version name
$content = $content -replace 'versionName\s*=\s*"[^"]+"', "versionName = `"$newVersionName`""

# Write back to file
$content | Set-Content $buildGradlePath -NoNewline

Write-Host "✓ Version updated in build.gradle.kts" -ForegroundColor Green
Write-Host ""

# Build bundle if requested
if ($BuildBundle) {
    Write-Host "Building release bundle..." -ForegroundColor Cyan
    .\gradlew.bat bundleRelease --no-daemon 2>&1 | Out-Null

    if ($LASTEXITCODE -eq 0) {
        $bundlePath = "app\build\outputs\bundle\release\app-release.aab"
        if (Test-Path $bundlePath) {
            $fileInfo = Get-Item $bundlePath
            Write-Host ""
            Write-Host "✓ Bundle built successfully!" -ForegroundColor Green
            Write-Host "  Location: $(Resolve-Path $bundlePath)" -ForegroundColor Gray
            Write-Host "  Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB" -ForegroundColor Gray
            Write-Host ""
            Write-Host "Ready to upload to Play Store!" -ForegroundColor Green
        } else {
            Write-Host "Warning: Bundle file not found" -ForegroundColor Yellow
        }
    } else {
        Write-Host "Error: Build failed" -ForegroundColor Red
        exit 1
    }
} else {
    Write-Host "To build the bundle, run:" -ForegroundColor Yellow
    Write-Host "  .\gradlew.bat bundleRelease" -ForegroundColor Gray
}

Write-Host ""
Write-Host "Summary:" -ForegroundColor Cyan
Write-Host "  Version Code: $newVersionCode" -ForegroundColor White
Write-Host "  Version Name: $newVersionName" -ForegroundColor White
Write-Host ""



================================================================
End of Codebase
================================================================
